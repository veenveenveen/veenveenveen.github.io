{"pages":[{"title":"关于我","text":"","link":"/about/index.html"},{"title":"二叉树遍历、节点数和深度计算","text":"二叉树遍历、节点数和深度计算123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149/* 递归算法和非递归算法 二叉树遍历：层次遍历 先(根)序遍历、中序遍历、后序遍历 */#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x): val(x), left(NULL), right(NULL) {}};class Solution {public: // 先序遍历 void preorderTraversal(TreeNode *root) { if (root) { cout &lt;&lt; root-&gt;val &lt;&lt; &quot;-&gt;&quot;; preorderTraversal(root-&gt;left); preorderTraversal(root-&gt;right); } } // 中序遍历 void inorderTraversal(TreeNode *root) { if (root) { inorderTraversal(root-&gt;left); cout &lt;&lt; root-&gt;val &lt;&lt; &quot;-&gt;&quot;; inorderTraversal(root-&gt;right); } } // 后序遍历 void postOrderTraversal(TreeNode *root) { if (root) { postOrderTraversal(root-&gt;left); postOrderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;val &lt;&lt; &quot;-&gt;&quot;; } } // 层次遍历 void levelOrderTraversal(TreeNode *root) { if (root) { queue&lt;TreeNode *&gt; q; q.push(root); while (!q.empty()) { TreeNode *node = q.front(); cout &lt;&lt; node-&gt;val &lt;&lt; &quot;-&gt;&quot;; if (node-&gt;left) { q.push(node-&gt;left); } if (node-&gt;right) { q.push(node-&gt;right); } q.pop(); } } } // 二叉树的节点总数 int nodeCount(TreeNode *root) { if (!root) { return 0; } return 1+nodeCount(root-&gt;left)+nodeCount(root-&gt;right); } // 二叉树的深度(最大深度) int depthOfTree(TreeNode *root) { if (!root) { return 0; } else { return max(depthOfTree(root-&gt;left), depthOfTree(root-&gt;right))+1; } } // 二叉树的最小深度 int minDepthOfTree(TreeNode *root) { if (!root) { return 0; } else { int leftDepth = minDepthOfTree(root-&gt;left); int rightDepth = minDepthOfTree(root-&gt;right); if (leftDepth == 0 || rightDepth == 0) { return leftDepth+rightDepth+1; } return min(leftDepth, rightDepth)+1; } } // 二叉树叶子节点数 int leafNodeCount(TreeNode *root) { if (!root) { return 0; } else { if (!root-&gt;left &amp;&amp; !root-&gt;right) { return 1; } return leafNodeCount(root-&gt;left)+leafNodeCount(root-&gt;right); } } // 二叉树创建 TreeNode *createTree() { TreeNode *p; int val; cin &gt;&gt; val; if (val == 0) { p = NULL; } else { p = new TreeNode(val); p-&gt;left = createTree(); p-&gt;right = createTree(); } return p; }};int main(int argc, const char * argv[]) { // TreeNode *tree = new TreeNode(1);// tree-&gt;left = new TreeNode(2);// tree-&gt;right = new TreeNode(3);// tree-&gt;right-&gt;left = new TreeNode(4);// tree-&gt;right-&gt;right = new TreeNode(5); TreeNode *tree = Solution().createTree(); cout &lt;&lt; &quot;节点总数 = &quot; + to_string(Solution().nodeCount(tree)) &lt;&lt; endl; cout &lt;&lt; &quot;二叉树的深度 = &quot; + to_string(Solution().depthOfTree(tree)) &lt;&lt; endl; cout &lt;&lt; &quot;二叉树的最小深度 = &quot; + to_string(Solution().minDepthOfTree(tree)) &lt;&lt; endl; cout &lt;&lt; &quot;二叉树的叶子节点数 = &quot; + to_string(Solution().leafNodeCount(tree)) &lt;&lt; endl; cout &lt;&lt; &quot;先序遍历\\n&quot;; Solution().preorderTraversal(tree); cout &lt;&lt; endl; cout &lt;&lt; &quot;中序遍历\\n&quot;; Solution().inorderTraversal(tree); cout &lt;&lt; endl; cout &lt;&lt; &quot;后序遍历\\n&quot;; Solution().postOrderTraversal(tree); cout &lt;&lt; endl; cout &lt;&lt; &quot;层次遍历\\n&quot;; Solution().levelOrderTraversal(tree); cout &lt;&lt; endl; return 0;}","link":"/exclude/Algorithms/binaryTreeTraversal.html"},{"title":"斐波那契数列","text":"斐波那契数列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 返回数组vector&lt;uint64_t&gt; fibonaccis(int n) { if (n &lt;= 0) { vector&lt;uint64_t&gt; fibs{0}; return fibs; } vector&lt;uint64_t&gt; fibs(n,1); if (n == 1 || n == 2) { return fibs; } for (int i = 2; i &lt; n; i++) { fibs[i] = fibs[i-2] + fibs[i-1]; } return fibs;}// 返回第n个数int fibonacci(int n) { if (n &lt;= 0) { return 0; } if (n == 1 || n == 2) { return 1; } int f1 = 1; int f2 = 1; for (int i = 3; i &lt;= n; i++) { int temp = f1 + f2; f1 = f2; f2 = temp; } return f2;}int main(int argc, const char * argv[]) { // insert code here...// std::cout &lt;&lt; fibonacci(47) &lt;&lt; std::endl; // uint std::cout &lt;&lt; fibonacci(46) &lt;&lt; std::endl; int n = 94; vector&lt;uint64_t&gt; fibs = fibonaccis(n); for (int i = 0; i &lt; n; i++) { cout &lt;&lt; fibs[i] &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl; cout &lt;&lt; UINT8_MAX; return 0;}","link":"/exclude/Algorithms/fibonacci.html"},{"title":"二叉树反转","text":"二叉树反转1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* Invert a binary tree. Example: Input: 4 / \\ 2 7 / \\ / \\ 1 3 6 9 Output: 4 / \\ 7 2 / \\ / \\ 9 6 3 1 Trivia: This problem was inspired by this original tweet by Max Howell: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so f*** off. */#include &lt;iostream&gt;using namespace std;/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x):val(x),left(NULL),right(NULL){}};class Solution {public: TreeNode* invertTree(TreeNode* root) { if (!root) { return NULL; } TreeNode *left = invertTree(root-&gt;left); TreeNode *right = invertTree(root-&gt;right); root-&gt;left = right; root-&gt;right = left; return root; }};int main(int argc, const char * argv[]) { // insert code here... std::cout &lt;&lt; &quot;Hello, World!\\n&quot;; return 0;}","link":"/exclude/Algorithms/invertBinaryTree.html"},{"title":"最长回文子串","text":"最长回文子串12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. Example 1: Input: &quot;babad&quot; Output: &quot;bab&quot; Note: &quot;aba&quot; is also a valid answer. Example 2: Input: &quot;cbbd&quot; Output: &quot;bb&quot; */#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Solution {public: string longestPalindrome(string s) { int n = int(s.length()), start = 0, end = 0; for (int i = 0; i &lt; n; i++) { int len1 = expandAroundCenter(s, i, i); int len2 = expandAroundCenter(s, i, i+1); int len = max(len1, len2); cout &lt;&lt; &quot;len = &quot; &lt;&lt; len &lt;&lt; endl; if (len &gt; end-start+1) {// 是否有等号 start = i-(len-1)/2; end = i+len/2; cout &lt;&lt; &quot;start = &quot; &lt;&lt; start&lt;&lt; &quot;, end = &quot; &lt;&lt; end &lt;&lt; &quot;, str = &quot; &lt;&lt; string(s,start,end-start+1) &lt;&lt; endl; } } if (end-start == 0) { return &quot;null&quot;; } return string(s,start,end-start+1); }private: int expandAroundCenter(string s, int left, int right) { int l = left, r = right; while (l &gt;= 0 &amp;&amp; r &lt; int(s.length()) &amp;&amp; s[l] == s[r]) { l--; r++; } return r-l-1; }};int main(int argc, const char * argv[]) { // insert code here... Solution solution; std::cout &lt;&lt; solution.longestPalindrome(&quot;vassademasds&quot;) &lt;&lt; endl; return 0;}","link":"/exclude/Algorithms/longestPalindromicSubstring.html"},{"title":"判断是否是回文数","text":"判断是否是回文数12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward. Example 1: Input: 121 Output: true Example 2: Input: -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3: Input: 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. */#include &lt;iostream&gt;class Solution {public: bool isPalindrome(int x) { if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x!=0 )) { return false; } int revertedNum = 0; while (x &gt; revertedNum) { revertedNum = revertedNum * 10 + x % 10; x = x / 10; } return x == revertedNum || x == revertedNum/10; }};int main(int argc, const char * argv[]) { // insert code here... Solution solution; std::cout &lt;&lt; solution.isPalindrome(1221) &lt;&lt; std::endl; return 0;}","link":"/exclude/Algorithms/palindromeNumber.html"},{"title":"合并两个排序链表","text":"合并两个排序链表1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* Merge Two Sorted Lists DescriptionHintsSubmissionsDiscussSolution Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists. Example: Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4 Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 */#include &lt;iostream&gt;using namespace std;struct ListNode { int val; ListNode *next; ListNode(int x):val(x),next(NULL){}};class Solution {public: ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) { ListNode *resList = new ListNode(0); ListNode *currNode = resList; while (l1 != NULL || l2 != NULL) { if (l1 == NULL) { currNode-&gt;next = l2; break; } if (l2 == NULL) { currNode-&gt;next = l1; break; } if (l1 != NULL &amp;&amp; l2 != NULL) { if (l1-&gt;val &lt; l2-&gt;val) { currNode-&gt;next = new ListNode(l1-&gt;val); l1 = l1-&gt;next; } else { currNode-&gt;next = new ListNode(l2-&gt;val); l2 = l2-&gt;next; } currNode = currNode-&gt;next; } } return resList-&gt;next; }};int main(int argc, const char * argv[]) { // insert code here... ListNode *l1 = new ListNode(1); l1-&gt;next = new ListNode(3); l1-&gt;next-&gt;next = new ListNode(5); ListNode *l2 = new ListNode(2); l2-&gt;next = new ListNode(4); l2-&gt;next-&gt;next = new ListNode(6); l2-&gt;next-&gt;next-&gt;next = new ListNode(7); ListNode *l = Solution().mergeTwoLists(l1, l2); while (l != NULL) { cout &lt;&lt; l-&gt;val &lt;&lt; &quot;-&gt;&quot;; l = l-&gt;next; } std::cout &lt;&lt; endl; return 0;}","link":"/exclude/Algorithms/mergeTwoSortedLists.html"},{"title":"整数反转","text":"整数反转123456789101112131415161718192021222324252627282930313233343536373839404142434445/* Given a 32-bit signed integer, reverse digits of an integer. Example 1: Input: 123 Output: 321 Example 2: Input: -123 Output: -321 Example 3: Input: 120 Output: 21 */#include &lt;iostream&gt;using namespace std;class Solution {public: int reverse(int x) { int res = 0; while (x != 0) { int tmp = x%10; if (res &gt; INT_MAX/10 || (res == INT_MAX/10 &amp;&amp; tmp &gt; 7)) { return 0; } // 判断是否会溢出 if (res &lt; INT_MIN/10 || (res == INT_MIN/10 &amp;&amp; tmp &lt; -8)) { return 0; } res = res * 10 + tmp; x = x/10; } return res; }};int main(int argc, const char * argv[]) { // insert code here... Solution solution; int res = solution.reverse(-2147483412); std::cout &lt;&lt; res &lt;&lt; endl; return 0;}","link":"/exclude/Algorithms/reverseInteger.html"},{"title":"pow(x,n)","text":"pow(x,n)123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;class Solution {public: double fun(double x, int n) { if (n == 0) { return 1; } double half = fun(x, n/2); if (n&amp;1) { return x*half*half; } else { return half*half; } } double myPow(double x, int n) { double res = fun(x, n); return n &gt; 0 ? res : 1/res; }};int main(int argc, const char * argv[]) { // insert code here... Solution solution; std::cout &lt;&lt; solution.myPow(-0.00001, -10) &lt;&lt; endl; cout &lt;&lt; pow(-0.00001, -10) &lt;&lt; endl; return 0;}","link":"/exclude/Algorithms/pow_x_n.html"},{"title":"判断二叉树是否相等","text":"判断二叉树是否相等1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example 1: Input: 1 1 / \\ / \\ 2 3 2 3 [1,2,3], [1,2,3] Output: true Example 2: Input: 1 1 / \\ 2 2 [1,2], [1,null,2] Output: false Example 3: Input: 1 1 / \\ / \\ 2 1 1 2 [1,2,1], [1,1,2] Output: false */#include &lt;iostream&gt;/** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {}};class Solution {public: bool isSameTree(TreeNode* p, TreeNode* q) { if (p == NULL &amp;&amp; q == NULL ) { return true; } if (p == NULL || q == NULL) { return false; } if (p-&gt;val != q-&gt;val) { return false; } return isSameTree(p-&gt;left, q-&gt;left) &amp;&amp; isSameTree(p-&gt;right, q-&gt;right); }};int main(int argc, const char * argv[]) { TreeNode *tree1 = new TreeNode(1); tree1-&gt;left = new TreeNode(2); tree1-&gt;right = new TreeNode(3); TreeNode *tree2 = new TreeNode(1); tree2-&gt;left = new TreeNode(2); tree2-&gt;right = new TreeNode(4); std::cout &lt;&lt; Solution().isSameTree(tree1, tree2) &lt;&lt; endl; return 0;}","link":"/exclude/Algorithms/sameTree.html"},{"title":"单链表反转","text":"单链表反转12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;struct ListNode { int val; ListNode *next; ListNode(int x):val(x),next(NULL){}};class Solution {public: // 单链表反转 ListNode *reverse(ListNode *head) { if (!head) { return NULL; } ListNode *pCurrent, *pPre, *pNext; pPre = head; pCurrent = pPre-&gt;next; while (pCurrent) { pNext = pCurrent-&gt;next; pCurrent-&gt;next = pPre; pPre = pCurrent; pCurrent = pNext; } head-&gt;next = NULL; head = pPre; return head; }};","link":"/exclude/Algorithms/singleLinkedListReverse.html"},{"title":"排序算法","text":"排序算法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171/* 排序 插入排序、选择排序、冒泡排序、梳排序 快速排序、希尔排序、基数排序、桶排序、归并排序、计数排序 */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;tuple&gt;using namespace std;class Solution {public: // 插入排序 void insertionSort(vector&lt;int&gt; &amp;nums) { for (int i = 1,j; i &lt; nums.size(); i++) { int tmp = nums[i]; for (j = i; j &gt; 0 &amp;&amp; tmp &lt; nums[j-1]; j--) { nums[j] = nums[j-1]; } nums[j] = tmp; } } // 选择排序 void selectionSort(vector&lt;int&gt; &amp;nums) { int n = int(nums.size()); for (int i = 0; i &lt; n-1; i++) { int p = i; for (int j = i+1; j &lt; n; j++) { if (nums[j] &lt; nums[p]) { p = j; } } if (i != p) { swap(nums[i], nums[p]); } } } // 冒泡排序 void bubbleSort(vector&lt;int&gt; &amp;nums) { int len = int(nums.size()); for (int i = 0; i &lt;len-1; i++) { bool flag = true; for (int j = 0; j &lt; len-i-1; j++) { if (nums[j] &gt; nums[j+1]) { flag = false; swap(nums[j], nums[j+1]); } } if (flag) { break; } } } // 希尔排序 void shellSort(vector&lt;int&gt; &amp;nums) { int step = 3;// 设定步长 int h = 1; while (h*step &lt; nums.size()) { h = h * step + 1; } while (h &gt;= 1) { for (int i = 1; i &lt; nums.size(); i++) { for (int j = i; j-h &gt;= 0 &amp;&amp; nums[j-h] &gt; nums[j] ; j = j-h) { swap(nums[j-h], nums[j]); } } h = h / step; } } // 快速排序 int partition(vector&lt;int&gt; &amp;nums, int low, int high) { int key = nums[low]; while (low &lt; high) { while (low &lt; high &amp;&amp; nums[high] &gt;= key) { high--; } nums[low] = nums[high]; while (low &lt; high &amp;&amp; nums[low] &lt;= key) { low++; } nums[high] = nums[low]; } nums[low] = key; return low; } void quickSort(vector&lt;int&gt; &amp;nums, int low, int high) { if (low &lt; high) { int tmp = partition(nums, low, high); cout &lt;&lt; &quot;tmp == &quot; &lt;&lt; tmp &lt;&lt; endl; quickSort(nums, low, tmp-1); quickSort(nums, tmp+1, high); } } // 归并排序 void mergeTwo(vector&lt;int&gt; &amp;nums, int first, int mid, int last) { vector&lt;int&gt; tmp(last-first+1); int i = first, j = mid+1, k = 0; while (i &lt;= mid &amp;&amp; j &lt;= last ) { if (nums[i] &lt; nums[j]) { tmp[k++] = nums[i++]; } else { tmp[k++] = nums[j++]; } } while (i &lt;= mid) { tmp[k++] = nums[i++]; } while (j &lt;= last) { tmp[k++] = nums[j++]; } i = first; k = 0; while (k &lt; tmp.size()) { nums[i++] = tmp[k++]; } } void mergeSort(vector&lt;int&gt; &amp;nums, int first, int last) { if (first &lt; last) { int mid = first+(last-first)/2; mergeSort(nums, first, mid); mergeSort(nums, mid+1, last); mergeTwo(nums, first, mid, last); } } int Add(int num1, int num2) { int sum=0; int a=0; do { sum=num1^num2; //不进位的结果 a=(num1&amp;num2)&lt;&lt;1; //只进位的结果 num1=sum; num2=a; } while(num2!=0); return num1; } };void printVector(string name, vector&lt;int&gt; &amp;nums) { cout &lt;&lt; name + &quot;: &quot;; for (int num : nums) { cout &lt;&lt; num &lt;&lt; &quot; &quot;; } cout &lt;&lt; endl;}int main(int argc, const char * argv[]) { vector&lt;int&gt; nums{4,6,3,10,12,2,8,1,9};// Solution().insertionSort(nums);// Solution().selectionSort(nums);// Solution().bubbleSort(nums);// Solution().shellSort(nums);// Solution().quickSort(nums, 0, int(nums.size())-1); Solution().mergeSort(nums, 0, int(nums.size())-1); printVector(&quot;sort&quot;, nums); cout &lt;&lt; &quot;sum = &quot; &lt;&lt; Solution().Add(43, 30) &lt;&lt; endl; return 0;}","link":"/exclude/Algorithms/sort.html"},{"title":"两数之和问题","text":"两数之和问题1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Solution {public: vector&lt;int&gt;twoSum(vector&lt;int&gt; &amp;nums, int target) { map&lt;int,int&gt; mapping; vector&lt;int&gt; result; int len = int(nums.size()); for (int i = 0; i &lt; len; i++) { mapping[nums[i]] = i; } for (int j = 0; j &lt; len; j++) { int searched = target - nums[j]; if (mapping.find(searched) != mapping.end() &amp;&amp; j != nums[searched]) { result.push_back(j); result.push_back(mapping[searched]); break; } } return result; }};int main(int argc, const char * argv[]) { // insert code here... vector&lt;int&gt; test{1,3,4,5,6}; Solution solution; vector&lt;int&gt; res = solution.twoSum(test, 7); for (int i = 0; i &lt; res.size(); i++) { cout &lt;&lt; res[i] &lt;&lt;&quot; &quot;; } cout &lt;&lt; endl; return 0;}","link":"/exclude/Algorithms/twoSum.html"},{"title":"有效性验证","text":"‘{ }’、’[ ]’、’( )’ 有效性验证 ‘{ }’、’[ ]’、’( )’ 有效性验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if: Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Note that an empty string is also considered valid. Example 1: Input: &quot;()&quot; Output: true Example 2: Input: &quot;()[]{}&quot; Output: true Example 3: Input: &quot;(]&quot; Output: false Example 4: Input: &quot;([)]&quot; Output: false Example 5: Input: &quot;{[]}&quot; Output: true */#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Solution {public: bool isValid(string s) { if (s.length() == 0) { return true; } vector&lt;char&gt; stack; map&lt;char, char&gt; mapping{{'(',')'},{'{','}'},{'[',']'}}; stack.push_back(s[0]); for (int i = 1; i &lt; s.length(); i++) { if (mapping[stack.back()] == s[i]) { stack.pop_back(); } else { stack.push_back(s[i]); } } return stack.empty(); }};int main(int argc, const char * argv[]) { // insert code here... std::cout &lt;&lt; Solution().isValid(&quot;}{(({}))&quot;) &lt;&lt; endl; return 0;}","link":"/exclude/Algorithms/validParentheses.html"},{"title":"SQL(1)","text":"SQL摘自廖雪峰SQL教程：原文 主键选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。 因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均不可用作主键。 作为主键最好是完全业务无关的字段，我们一般把这个字段命名为id。常见的可作为id字段的类型有： 自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键； 全局唯一GUID类型：使用一种全局唯一的字符串作为主键，类似8f55d96b-8acc-4636-8cb8-76bf8abc2f57。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。 外键在某一张表中，通过某一个字段，可以把数据与另一张表关联起来，这种列称为外键。 外键并不是通过列名实现的，而是通过定义外键约束实现的： 1234ALTER TABLE studentsADD CONSTRAINT fk_class_idFOREIGN KEY (class_id)REFERENCES classes (id); 其中，外键约束的名称fk_class_id可以任意，FOREIGN KEY (class_id)指定了class_id作为外键，REFERENCES classes (id)指定了这个外键将关联到classes表的id列（即classes表的主键）。 由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，class_id仅仅是一个普通的列，只是它起到了外键的作用而已。 要删除一个外键约束，也是通过ALTER TABLE实现的： 12ALTER TABLE studentsDROP FOREIGN KEY fk_class_id; 注意：删除外键约束并没有删除外键这一列。删除列是通过DROP COLUMN ...实现的。 索引在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。 索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。 索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如gender列，大约一半的记录值是M，另一半是F，因此，对该列创建索引就没有意义。 可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。 对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。 唯一索引在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。 但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设students表的name不能重复： 12ALTER TABLE studentsADD UNIQUE INDEX uni_name (name); 通过UNIQUE关键字我们就添加了一个唯一索引。 也可以只对某一列添加一个唯一约束而不创建唯一索引： 12ALTER TABLE studentsADD CONSTRAINT uni_name UNIQUE (name); 这种情况下，name列没有索引，但仍然具有唯一性保证。 无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。 准备数据准备了一个students表和一个classes表，它们的结构和数据如下： students表存储了学生信息：| id | class_id | name | gender | score || :—–: | :—–: | :—–: | :—–: | :—–: || 1 | 1 | 小明 | M | 90 || 2 | 1 | 小红 | F | 95 || 3 | 1 | 小军 | M | 88 || 4 | 1 | 小米 | F | 73 || 5 | 2 | 小白 | F | 81 || 6 | 2 | 小兵 | M | 55 || 7 | 2 | 小林 | M | 85 || 8 | 3 | 小新 | F | 91 || 9 | 3 | 小王 | M | 89 || 10 | 3 | 小丽 | F | 85 | classes表存储了班级信息：| id | name || :—–: | :—–: || 1 | 一班 || 2 | 二班 || 3 | 三班 || 4 | 四班 |","link":"/exclude/Database/sql_0.html"},{"title":"SQL(3)","text":"修改数据关系数据库的基本操作就是增删改查，即CRUD：Create、Retreive、Update、Delete。 对于查询使用的SQL语句为SELECT;对于增、删、改，对应的SQL语句分别是： INSERT：插入新记录； UPDATE：更新已有记录； DELETE：删除已有记录。 插入数据INSERT语句的基本语法是： 1INSERT INTO &lt;表名&gt; (字段1, 字段2, ...) VALUES (值1, 值2, ...); 例如，我们向students表插入一条新记录，先列举出需要插入的字段名称，然后在VALUES子句中依次写出对应字段的值： 1234-- 添加一条新记录INSERT INTO students (class_id, name, gender, score) VALUES (2, '大牛', 'M', 80);-- 查询并观察结果:SELECT * FROM students; 注意到我们并没有列出id字段，也没有列出id字段对应的值，这是因为id字段是一个自增主键，它的值可以由数据库自己推算出来。此外，如果一个字段有默认值，那么在INSERT语句中也可以不出现。 要注意，字段顺序不必和数据库表的字段顺序一致，但值的顺序必须和字段顺序一致。也就是说，可以写INSERT INTO students (score, gender, name, class_id) ...，但是对应的VALUES就得变成(80, 'M', '大牛', 2)。 还可以一次性添加多条记录，只需要在VALUES子句中指定多个记录值，每个记录是由(...)包含的一组值： 1234-- 一次性添加多条新记录INSERT INTO students (class_id, name, gender, score) VALUES (1, '大宝', 'M', 87), (2, '二宝', 'M', 81); 更新数据UPDATE语句的基本语法是： 1UPDATE &lt;表名&gt; SET 字段1=值1, 字段2=值2, ... WHERE ...; 例如，我们想更新students表id=1的记录的name和score这两个字段，先写出UPDATE students SET name='大牛', score=66，然后在WHERE子句中写出需要更新的行的筛选条件id=1： 12-- 更新id=1的记录UPDATE students SET name='大牛', score=66 WHERE id=1; 注意到UPDATE语句的WHERE条件和SELECT语句的WHERE条件其实是一样的，因此完全可以一次更新多条记录： 12-- 更新id=5,6,7的记录UPDATE students SET name='小牛', score=77 WHERE id&gt;=5 AND id&lt;=7; 在UPDATE语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分： 12-- 更新score&lt;80的记录UPDATE students SET score=score+10 WHERE score&lt;80; 其中，SET score=score+10就是给当前行的score字段的值加上了10。 如果WHERE条件没有匹配到任何记录，UPDATE语句不会报错，也不会有任何记录被更新。例如： 12-- 更新id=999的记录UPDATE students SET score=100 WHERE id=999; 最后，要特别小心的是，UPDATE语句可以没有WHERE条件，例如：UPDATE students SET score=60;这时，整个表的所有记录都会被更新。所以，在执行UPDATE语句时要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用UPDATE更新。 MySQL在使用MySQL这类真正的关系数据库时，UPDATE语句会返回更新的行数以及WHERE条件匹配的行数。 例如，更新id=1的记录时： 123mysql&gt; UPDATE students SET name='大宝' WHERE id=1;Query OK, 1 row affected (0.00 sec)Rows matched: 1 Changed: 1 Warnings: 0 MySQL会返回1，可以从打印的结果Rows matched: 1 Changed: 1看到。 当更新id=999的记录时： 123mysql&gt; UPDATE students SET name='大宝' WHERE id=999;Query OK, 0 rows affected (0.00 sec)Rows matched: 0 Changed: 0 Warnings: 0 MySQL会返回0，可以从打印的结果Rows matched: 0 Changed: 0看到。 删除数据DELETE语句的基本语法是： 1DELETE FROM &lt;表名&gt; WHERE ...; 例如，我们想删除students表中id=1的记录，就需要这么写： 1DELETE FROM students WHERE id=1; 注意到DELETE语句的WHERE条件也是用来筛选需要删除的行，因此和UPDATE类似，DELETE语句也可以一次删除多条记录： 1DELETE FROM students WHERE id&gt;=5 AND id&lt;=7; 如果WHERE条件没有匹配到任何记录，DELETE语句不会报错，也不会有任何记录被删除。例如： 1DELETE FROM students WHERE id=999; 最后，要特别小心的是，和UPDATE类似，不带WHERE条件的DELETE语句会删除整个表的数据：DELETE FROM students;;这时，整个表的所有记录都会被删除。所以，在执行DELETE语句时也要非常小心，最好先用SELECT语句来测试WHERE条件是否筛选出了期望的记录集，然后再用DELETE删除。 MySQL 在使用MySQL这类真正的关系数据库时，DELETE语句也会返回删除的行数以及WHERE条件匹配的行数。 例如，分别执行删除id=1和id=999的记录： 12345mysql&gt; DELETE FROM students WHERE id=1;Query OK, 1 row affected (0.01 sec)mysql&gt; DELETE FROM students WHERE id=999;Query OK, 0 rows affected (0.01 sec)","link":"/exclude/Database/sql_2.html"},{"title":"SQL(4)","text":"MySQL安装完MySQL后，除了MySQL Server，即真正的MySQL服务器外，还附赠一个MySQL Client程序。MySQL Client是一个命令行客户端，可以通过MySQL Client登录MySQL，然后，输入SQL语句并执行。 打开命令提示符，输入命令mysql -u root -p，提示输入口令。填入MySQL的root口令，如果正确，就连上了MySQL Server，同时提示符变为mysql&gt;： 12345678910111213141516┌────────────────────────────────────────────────────────┐│Command Prompt - □ x │├────────────────────────────────────────────────────────┤│Microsoft Windows [Version 10.0.0] ││(c) 2015 Microsoft Corporation. All rights reserved. ││ ││C:\\&gt; mysql -u root -p ││Enter password: ****** ││ ││Server version: 5.7 ││Copyright (c) 2000, 2018, ... ││Type 'help;' or '\\h' for help. ││ ││mysql&gt; ││ │└────────────────────────────────────────────────────────┘ 输入exit断开与MySQL Server的连接并返回到命令提示符。 MySQL Client的可执行程序是mysql，MySQL Server的可执行程序是mysqld。MySQL Client和MySQL Server的关系如下： 123┌──────────────┐ SQL ┌──────────────┐│ MySQL Client │───────&gt;│ MySQL Server │└──────────────┘ TCP └──────────────┘ 在MySQL Client中输入的SQL语句通过TCP连接发送到MySQL Server。默认端口号是3306，即如果发送到本机MySQL Server，地址就是127.0.0.1:3306。 也可以只安装MySQL Client，然后连接到远程MySQL Server。假设远程MySQL Server的IP地址是10.0.1.99，那么就使用-h指定IP或域名： 1mysql -h 10.0.1.99 -u root -p","link":"/exclude/Database/sql_3.html"},{"title":"SQL(5)","text":"管理MySQL要管理MySQL，可以使用可视化图形界面MySQL Workbench或者Navicat Premium等。 MySQL Workbench可以用可视化的方式查询、创建和修改数据库表，但是，归根到底，MySQL Workbench是一个图形客户端，它对MySQL的操作仍然是发送SQL语句并执行。因此，本质上，MySQL Workbench和MySQL Client命令行都是客户端，和MySQL交互，唯一的接口就是SQL。 因此，MySQL提供了大量的SQL语句用于管理。虽然可以使用MySQL Workbench图形界面来直接管理MySQL，但是，很多时候，通过SSH远程连接时，只能使用SQL命令，所以，了解并掌握常用的SQL管理操作是必须的。 数据库在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）。要列出所有数据库，使用命令： 123456789101112mysql&gt; SHOW DATABASES;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema || shici || sys || test || school |+--------------------+ 其中，information_schema、mysql、performance_schema和sys是系统库，不要去改动它们。其他的是用户创建的数据库。 要创建一个新数据库，使用命令： 12mysql&gt; CREATE DATABASE test;Query OK, 1 row affected (0.01 sec) 要删除一个数据库，使用命令： 12mysql&gt; DROP DATABASE test;Query OK, 0 rows affected (0.01 sec) 注意：删除一个数据库将导致该数据库的所有表全部被删除。 对一个数据库进行操作时，要首先将其切换为当前数据库： 12mysql&gt; USE test;Database changed 表列出当前数据库的所有表，使用命令： 123456789mysql&gt; SHOW TABLES;+---------------------+| Tables_in_test |+---------------------+| classes || statistics || students || students_of_class1 |+---------------------+ 要查看一个表的结构，使用命令： 1234567891011mysql&gt; DESC students;+----------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+----------+--------------+------+-----+---------+----------------+| id | bigint(20) | NO | PRI | NULL | auto_increment || class_id | bigint(20) | NO | | NULL | || name | varchar(100) | NO | | NULL | || gender | varchar(1) | NO | | NULL | || score | int(11) | NO | | NULL | |+----------+--------------+------+-----+---------+----------------+5 rows in set (0.00 sec) 还可以使用以下命令查看创建表的SQL语句： 123456789101112mysql&gt; SHOW CREATE TABLE students;+----------+-------------------------------------------------------+| students | CREATE TABLE `students` ( || | `id` bigint(20) NOT NULL AUTO_INCREMENT, || | `class_id` bigint(20) NOT NULL, || | `name` varchar(100) NOT NULL, || | `gender` varchar(1) NOT NULL, || | `score` int(11) NOT NULL, || | PRIMARY KEY (`id`) || | ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 |+----------+-------------------------------------------------------+1 row in set (0.00 sec) 创建表使用CREATE TABLE语句，而删除表使用DROP TABLE语句： 12mysql&gt; DROP TABLE students;Query OK, 0 rows affected (0.01 sec) 修改表就比较复杂。如果要给students表新增一列birth，使用： 1ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL; 要修改birth列，例如把列名改为birthday，类型改为VARCHAR(20)： 1ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL; 要删除列，使用： 1ALTER TABLE students DROP COLUMN birthday; 退出MySQL使用EXIT命令退出MySQL： 12mysql&gt; EXITBye 注意EXIT仅仅断开了客户端和服务器的连接，MySQL服务器仍然继续运行。","link":"/exclude/Database/sql_4.html"},{"title":"SQL(6)","text":"实用SQL语句在编写SQL时，灵活运用一些技巧，可以大大简化程序逻辑。 插入或替换如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用REPLACE语句，这样就不必先查询，再决定是否先删除再插入： 1REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99); 若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。 插入或更新如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用INSERT INTO ... ON DUPLICATE KEY UPDATE ...语句： 1INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99) ON DUPLICATE KEY UPDATE name='小明', gender='F', score=99; 若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。 插入或忽略如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用INSERT IGNORE INTO ...语句： 1INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99); 若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。 快照如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT： 12-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1; 新创建的表结构和SELECT使用的表结构完全一致。 写入查询结果集如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中。 例如，创建一个统计成绩的表statistics，记录各班的平均成绩： 123456CREATE TABLE statistics ( id BIGINT NOT NULL AUTO_INCREMENT, class_id BIGINT NOT NULL, average DOUBLE NOT NULL, PRIMARY KEY (id)); 然后，我们就可以用一条语句写入各班的平均成绩： 1INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id; 确保INSERT语句的列和SELECT语句的列能一一对应，就可以在statistics表中直接保存查询的结果： 123456789&gt; select * from statistics;+----+----------+--------------+| id | class_id | average |+----+----------+--------------+| 1 | 1 | 86.5 || 2 | 2 | 73.666666666 || 3 | 3 | 88.333333333 |+----+----------+--------------+3 rows in set (0.00 sec)","link":"/exclude/Database/sql_5.html"},{"title":"SQL(7)","text":"事务在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作： 12345-- 从id=1的账户给id=2的账户转账100元-- 第一步：将id=1的A账户余额减去100UPDATE accounts SET balance = balance - 100 WHERE id = 1;-- 第二步：将id=2的B账户余额加上100UPDATE accounts SET balance = balance + 100 WHERE id = 2; 这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。 这种把多条语句作为一个整体进行操作的功能，被称为数据库事务。数据库事务可以确保该事务范围内的所有操作都可以全部成功或者全部失败。如果事务失败，那么效果就和没有执行这些SQL一样，不会对数据库数据有任何改动。 可见，数据库事务具有ACID这4个特性： A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行； C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100； I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离； D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。 对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。 要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为显式事务，例如，把上述的转账操作作为一个显式事务： 1234BEGIN;UPDATE accounts SET balance = balance - 100 WHERE id = 1;UPDATE accounts SET balance = balance + 100 WHERE id = 2;COMMIT; 很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。 COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存。如果COMMIT语句执行失败了，整个事务也会失败。 有些时候，我们希望主动让事务失败，这时，可以用ROLLBACK回滚事务，整个事务会失败： 1234BEGIN;UPDATE accounts SET balance = balance - 100 WHERE id = 1;UPDATE accounts SET balance = balance + 100 WHERE id = 2;ROLLBACK; 数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。","link":"/exclude/Database/sql_6.html"},{"title":"SQL(8)","text":"隔离级别对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。 SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：| Isolation Level | 脏读（Dirty Read） | 不可重复读（Non Repeatable Read） | 幻读（Phantom Read） || :—–: | :—–: | :—–: | :—–: || Read Uncommitted | Yes | Yes | Yes || Read Committed | - | Yes | Yes || Repeatable Read | - | - | Yes || Serializable | - | - | - | Read UncommittedRead Uncommitted是隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是脏读（Dirty Read）。 我们来看一个例子。 首先，我们准备好students表的数据，该表仅一行记录： 1234567mysql&gt; select * from students;+----+-------+| id | name |+----+-------+| 1 | Alice |+----+-------+1 row in set (0.00 sec) 然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：| 时刻 | 事务A | 事务B || :—–: | :—–: | :—–: || 1 | SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; | SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;| 2 | BEGIN; | BEGIN;| 3 | UPDATE students SET name = ‘Bob’ WHERE id = 1; | || 4 | | SELECT * FROM students WHERE id = 1; || 5 | ROLLBACK; | || 6 | | SELECT * FROM students WHERE id = 1; || 7 | | COMMIT; | 当事务A执行完第3步时，它更新了id=1的记录，但并未提交，而事务B在第4步读取到的数据就是未提交的数据。 随后，事务A在第5步进行了回滚，事务B再次读取id=1的记录，发现和上一次读取到的数据不一致，这就是脏读。 可见，在Read Uncommitted隔离级别下，一个事务可能读取到另一个事务更新但未提交的数据，这个数据有可能是脏数据。 Read Committed在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。 不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。 我们仍然先准备好students表的数据： 1234567mysql&gt; select * from students;+----+-------+| id | name |+----+-------+| 1 | Alice |+----+-------+1 row in set (0.00 sec) 然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：| 时刻 | 事务A | 事务B || :—–: | :—–: | :—–: || 1 | SET TRANSACTION ISOLATION LEVEL READ COMMITTED; | SET TRANSACTION ISOLATION LEVEL READ COMMITTED; || 2 | BEGIN; | BEGIN; || 3 | | SELECT * FROM students WHERE id = 1; || 4 | UPDATE students SET name = ‘Bob’ WHERE id = 1; | || 5 | COMMIT; | || 6 | | SELECT * FROM students WHERE id = 1; || 7 | | COMMIT; |当事务B第一次执行第3步的查询时，得到的结果是Alice，随后，由于事务A在第4步更新了这条记录并提交，所以，事务B在第6步再次执行同样的查询时，得到的结果就变成了Bob，因此，在Read Committed隔离级别下，事务不可重复读同一条记录，因为很可能读到的结果不一致。 Repeatable Read在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。 幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。 我们仍然先准备好students表的数据： 1234567mysql&gt; select * from students;+----+-------+| id | name |+----+-------+| 1 | Alice |+----+-------+1 row in set (0.00 sec) 然后，分别开启两个MySQL客户端连接，按顺序依次执行事务A和事务B：| 时刻 | 事务A | 事务B || :—–: | :—–: | :—–: || 1 | SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; | SET TRANSACTION ISOLATION LEVEL REPEATABLE READ; || 2 | BEGIN; | BEGIN; || 3 | | SELECT * FROM students WHERE id = 99; || 4 | INSERT INTO students (id, name) VALUES (99, ‘Bob’); | || 5 | COMMIT; | || 6 | | SELECT * FROM students WHERE id = 99; || 7 | | UPDATE students SET name = ‘Alice’ WHERE id = 99; || 8 | | SELECT * FROM students WHERE id = 99; || 9 | | COMMIT; |事务B在第3步第一次读取id=99的记录时，读到的记录为空，说明不存在id=99的记录。随后，事务A在第4步插入了一条id=99的记录并提交。事务B在第6步再次读取id=99的记录时，读到的记录仍然为空，但是，事务B在第7步试图更新这条不存在的记录时，竟然成功了，并且，事务B在第8步再次读取id=99的记录时，记录出现了。 可见，幻读就是没有读到的记录，以为不存在，但其实是可以更新成功的，并且，更新成功后，再次读取，就出现了。 SerializableSerializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。 虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。 默认隔离级别如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用InnoDB，默认的隔离级别是Repeatable Read。","link":"/exclude/Database/sql_7.html"},{"title":"正则表达式","text":"正则表达式 正则表达式摘自廖雪峰JavaScript教程：原文 字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取@前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。 正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。 所以我们判断一个字符串是否是合法的Email的方法是： 创建一个匹配Email的正则表达式； 用该正则表达式去匹配用户的输入来判断是否合法。 因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。 在正则表达式中，如果直接给出字符，就是精确匹配。用\\d可以匹配一个数字，\\w可以匹配一个字母或数字，所以： '00\\d'可以匹配'007'，但无法匹配'00A'； '\\d\\d\\d'可以匹配'010'； '\\w\\w'可以匹配'js'； .可以匹配任意字符，所以： 'js.'可以匹配'jsp'、'jss'、'js!'等等。 要匹配变长的字符，在正则表达式中，用*表示任意个字符（包括0个），用+表示至少一个字符，用?表示0个或1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符： 来看一个复杂的例子：\\d{3}\\s+\\d{3,8}。 我们来从左到右解读一下： \\d{3}表示匹配3个数字，例如'010'； \\s可以匹配一个空格（也包括Tab等空白符），所以\\s+表示至少有一个空格，例如匹配' '，'\\t\\t'等； \\d{3,8}表示3-8个数字，例如'1234567'。 综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。 如果要匹配'010-12345'这样的号码呢？由于'-'是特殊字符，在正则表达式中，要用'\\'转义，所以，上面的正则是\\d{3}\\-\\d{3,8}。 但是，仍然无法匹配'010 - 12345'，因为带有空格。所以我们需要更复杂的匹配方式。 进阶 要做更精确地匹配，可以用[]表示范围，比如： [0-9a-zA-Z\\_]可以匹配一个数字、字母或者下划线； [0-9a-zA-Z\\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'js2015'等等； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]*可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名； [a-zA-Z\\_\\$][0-9a-zA-Z\\_\\$]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。 A|B可以匹配A或B，所以(J|j)ava(S|s)cript可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。 ^表示行的开头，^\\d表示必须以数字开头。 $表示行的结束，\\d$表示必须以数字结束。 你可能注意到了，js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了。","link":"/exclude/Other/RegExp.html"},{"title":"RSA密钥对生成","text":"RSA密钥对生成 RSA密钥对生成 首先，在命令行执行以下命令以生成一个RSA密钥对： 1openssl genrsa -aes256 -out rsa-key.pem 2048 根据提示输入密码，这个密码是用来加密RSA密钥的，加密方式指定为AES256，生成的RSA的密钥长度是2048位。执行成功后，我们获得了加密的rsa-key.pem文件。 第二步，通过上面的rsa-key.pem加密文件，我们可以导出原始的私钥，命令如下： 1openssl rsa -in rsa-key.pem -outform PEM -out rsa-prv.pem 输入第一步的密码，我们获得了解密后的私钥。 类似的，我们用下面的命令导出原始的公钥： 1openssl rsa -in rsa-key.pem -outform PEM -pubout -out rsa-pub.pem 这样，我们就准备好了原始私钥文件rsa-prv.pem和原始公钥文件rsa-pub.pem，编码格式均为PEM。","link":"/exclude/Other/generateRSA.html"},{"title":"Reading","text":"有时候，我喜欢眼睁睁地看着时间，一秒一秒一秒一秒……地流逝，我无所谓，我无能为力。 – 几米","link":"/exclude/essay/README.html"},{"title":"AFNetworking 监听网络状态","text":"AFNetworking 监听网络状态123456789101112131415161718192021222324252627282930313233343536373839404142#import &quot;ViewController.h&quot;#import &quot;AFNetworking.h&quot;@interface ViewController ()@property (nonatomic, strong) AFNetworkReachabilityManager *manager;@end@implementation ViewController- (void)dealloc { [self.manager stopMonitoring];}- (void)viewDidLoad { [super viewDidLoad]; //创建网络监听对象 self.manager = [AFNetworkReachabilityManager sharedManager]; //开始监听 [self.manager startMonitoring]; //监听改变 [self.manager setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) { switch (status) { case AFNetworkReachabilityStatusUnknown: NSLog(@&quot;未识别的网络&quot;); break; case AFNetworkReachabilityStatusNotReachable: NSLog(@&quot;网络不可用&quot;); break; case AFNetworkReachabilityStatusReachableViaWWAN: NSLog(@&quot;2G,3G,4G...&quot;); break; case AFNetworkReachabilityStatusReachableViaWiFi: NSLog(@&quot;wifi网络&quot;); break; } }];}@end","link":"/exclude/iOS/AFNNetworkMonitor.html"},{"title":"AR图像识别","text":"AR图像识别使用系统自带API 在 Assets.xcassets 文件目录下新建一个 AR Resource Group 类型的目录并导入要识别的图片(导入后需要设置图片的size) 定义ARReferenceImage 对象并赋值给 ARWorldTrackingConfiguration的detectionImages属性 遵守ARSCNViewDelegate协议并在- (void)renderer:(id&lt;SCNSceneRenderer&gt;)renderer didAddNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;方法中获取参考图片对象，获取后进行图片判断。 工程中用到的模型资源地址：地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#import &quot;ARSCNViewController.h&quot;#import &lt;ARKit/ARKit.h&gt;#import &lt;SceneKit/SceneKit.h&gt;@interface ARSCNViewController () &lt;ARSessionDelegate, ARSCNViewDelegate&gt;@property (nonatomic, strong) ARSCNView *arScnView;@property (nonatomic, strong) ARSession *arSession;@property (nonatomic, strong) ARWorldTrackingConfiguration *arSessionConfiguration;@end@implementation ARSCNViewController- (void)viewDidLoad { [super viewDidLoad]; [self.view addSubview:self.arScnView]; { UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(20, 70, 60, 40)]; btn.layer.backgroundColor = UIColor.orangeColor.CGColor; [btn setTitle:@&quot;back&quot; forState:UIControlStateNormal]; [btn addTarget:self action:@selector(btnClick) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; [self.view bringSubviewToFront:btn]; } if (ARConfiguration.isSupported) {// 判断是否支持AR }}- (void)btnClick { [self dismissViewControllerAnimated:true completion:nil];}- (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; [self.arSession runWithConfiguration:self.arSessionConfiguration options:ARSessionRunOptionResetTracking |ARSessionRunOptionRemoveExistingAnchors];}- (void)viewWillDisappear:(BOOL)animated { [super viewWillDisappear:animated]; [self.arSession pause];}- (void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated];}#pragma mark -- (void)renderer:(id&lt;SCNSceneRenderer&gt;)renderer didAddNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor { ARImageAnchor * imageAnchor = (ARImageAnchor *)anchor; //获取参考图片对象 ARReferenceImage * referenceImage = imageAnchor.referenceImage; if ([referenceImage.name isEqual: @&quot;ar&quot;]) { NSLog(@&quot;referenceImage: ar&quot;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // Scene is modified when rendering callback NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;art.scnassets/skinning&quot; withExtension:@&quot;dae&quot;]; if (!url) { NSLog(@&quot;url 为空&quot;); return; } SCNReferenceNode *rNode = [[SCNReferenceNode alloc] initWithURL:url];// rNode.scale = SCNVector3Make(0.0005, 0.0005, 0.0005);// rNode.eulerAngles = SCNVector3Make(-M_PI/2.1, 0, 0); [rNode load]; rNode.scale = SCNVector3Make(0.0003, 0.0003, 0.0003); rNode.position = SCNVector3Make(0, -1, -1); dispatch_async(dispatch_get_main_queue(), ^{// [node addChildNode:rNode]; [self.arScnView.scene.rootNode addChildNode:rNode]; }); }); } if ([referenceImage.name isEqual: @&quot;ar2&quot;]) { NSLog(@&quot;referenceImage: ar2&quot;); SCNNode *tempNode = [SCNNode new]; CGFloat w = referenceImage.physicalSize.width; CGFloat h = referenceImage.physicalSize.height; SCNBox *box = [SCNBox boxWithWidth:w*0.5 height:w*0.5 length:h*0.5 chamferRadius:0]; box.firstMaterial.diffuse.contents = UIColor.orangeColor; tempNode.geometry = box; tempNode.eulerAngles = SCNVector3Make(-M_PI/2.0, -M_PI/2.0, 0); tempNode.opacity = 1;//透明度 //摇摆动画 SCNAction *action = [SCNAction rotateToX:-M_PI y:0 z:M_PI duration:2]; SCNAction *action1 = [SCNAction rotateToX:-M_PI y:0 z:-M_PI duration:2]; SCNAction *sequence =[SCNAction sequence:@[action, action1]]; [tempNode runAction:[SCNAction repeatAction:sequence count:MAXFLOAT]]; [node addChildNode:tempNode]; } if ([referenceImage.name isEqual: @&quot;ar3&quot;]) { NSLog(@&quot;referenceImage: ar3&quot;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // Scene is modified when rendering callback// SCNScene *scene = [SCNScene sceneNamed: @&quot;art.scnassets/ship.scn&quot;];// SCNNode *shipNode = scene.rootNode.childNodes[0]; //此方法加载模型位置不对 NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;art.scnassets/ship&quot; withExtension:@&quot;scn&quot;]; if (!url) { NSLog(@&quot;url 为空&quot;); return; } SCNReferenceNode *shipNode = [[SCNReferenceNode alloc] initWithURL:url]; shipNode.eulerAngles = SCNVector3Make(-M_PI/2.0, 0, 0); [shipNode load]; // shipNode.position = SCNVector3Make(0, -1, -1); dispatch_async(dispatch_get_main_queue(), ^{ //左右摇摆动画 SCNAction *action11 = [SCNAction rotateToX:-M_PI/2.0 y:0.5 z:0 duration:0.5]; SCNAction *action12 = [SCNAction rotateToX:-M_PI/2.0 y:-0.5 z:0 duration:0.5]; SCNAction *sequence1 =[SCNAction sequence:@[action11,action12]]; [shipNode runAction:[SCNAction repeatAction:sequence1 count:MAXFLOAT]]; [node addChildNode:shipNode];// [self.arScnView.scene.rootNode addChildNode:shipNode]; }); }); }}#pragma mark - &lt;ARSessionDelegate&gt;/// 会话位置更新（监听相机的移动），此代理方法会调用非常频繁，只要相机移动就会调用，如果相机移动过快，会有一定的误差，具体的需要强大的算法去优化- (void)session:(ARSession *)session didUpdateFrame:(ARFrame *)frame {// NSLog(@&quot;相机移动&quot;);}- (void)session:(ARSession *)session didAddAnchors:(NSArray&lt;ARAnchor *&gt; *)anchors {// NSLog(@&quot;添加锚点&quot;);}- (void)session:(ARSession *)session didUpdateAnchors:(NSArray&lt;ARAnchor *&gt; *)anchors {// NSLog(@&quot;刷新锚点&quot;);}- (void)session:(ARSession *)session didRemoveAnchors:(NSArray&lt;ARAnchor *&gt; *)anchors { NSLog(@&quot;移除锚点&quot;);}- (void)session:(ARSession *)session didFailWithError:(NSError *)error { NSLog(@&quot;message error: %@&quot;, error.description);}#pragma mark -- (ARSCNView *)arScnView { if (!_arScnView) { // 创建AR视图 _arScnView = [[ARSCNView alloc] initWithFrame:self.view.bounds]; _arScnView.delegate = self; // 设置视图会话 _arScnView.session = self.arSession; // Show statistics such as fps and timing information _arScnView.showsStatistics = YES; } return _arScnView;}// AR会话，负责管理相机追踪配置及3D相机坐标- (ARSession *)arSession { if (!_arSession) { _arSession = [[ARSession alloc] init]; _arSession.delegate = self; } return _arSession;}// 会话追踪配置：负责追踪相机的运动- (ARWorldTrackingConfiguration *)arSessionConfiguration { if (!_arSessionConfiguration) { // 创建世界追踪会话配置（使用ARWorldTrackingSessionConfiguration效果更加好），需要A9芯片支持 _arSessionConfiguration = [[ARWorldTrackingConfiguration alloc] init]; // 设置追踪方向（追踪平面）// _arSessionConfiguration.planeDetection = ARPlaneDetectionHorizontal; // 自适应灯光（相机从暗到强光快速过渡效果会平缓一些） _arSessionConfiguration.lightEstimationEnabled = true; // 图像检测 _arSessionConfiguration.detectionImages = [ARReferenceImage referenceImagesInGroupNamed:@&quot;AR Resources&quot; bundle:nil]; } return _arSessionConfiguration;}@end","link":"/exclude/iOS/ARImageDetect.html"},{"title":"App跳转微信小程序","text":"App跳转微信小程序 微信开放平台添加应用（需要应用的Bundle ID） 应用添加完成后点击‘查看’，找到关联小程序信息，把需要跳转的小程序和应用关联到一起（需要小程序的AppID） 微信开放平台的SDK集成（SDK下载地址：https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource） ① 项目配置：项目target的info中添加Scheme，URL Scheme为要跳转的微信小程序的AppID，info.plist设置添加Key: LSApplicationQueriesSchemes ② AppDelegate中进行注册以及实现代理方法WXApiDelegate， WXApi.registerApp()中的参数为微信开放平台添加的应用的AppID 1WXApi.registerApp(&quot;**********&quot;) ③ 发起跳转请求（比如在某个按钮点击事件中添加下面的代码）userName为小程序的原始ID (查找：设置-&gt;基本设置-&gt;原始ID) 1234let launchMiniProgramReq = WXLaunchMiniProgramReq.object()launchMiniProgramReq?.userName = &quot;gh_***&quot;launchMiniProgramReq?.miniProgramType = .releaseWXApi.send(launchMiniProgramReq)","link":"/exclude/iOS/AppToMiniProgram.html"},{"title":"Flutter与已有iOS工程混合开发","text":"Flutter与已有iOS工程混合开发混合开发参考：Add-Flutter-to-existing-apps 本文GitHub：地址 1. 创建工程目录，iOS工程、和Flutter工程为同级目录（本文只创建iOS的混合开发，Android混合开发可以参看flutter文档） 1234FlutterLearnMix |-iOS |-Android |-Flutter 2. 在iOS工程目录下新建iOS工程（创建方法省略，我在iOS目录下创建的工程名为FlutterLearnMix）， Flutter混合开发不支持bit code，所以在iOS工程里关闭 Build Setting -&gt; Enable Bitcode -&gt; 设置为NO，这里使用CocoaPods管理，需要先pod init初始化 3. Flutter Module搭建: 切换到FlutterLearnMix/Flutter目录，执行flutter create -t module flutter_module 4. 使iOS工程依赖Flutter Module：将flutter_module添加到Podfile文件中，内容如下，可以使用绝对路径，亦可以使用相对路径，添加完后执行pod install 12345678910111213# Uncomment the next line to define a global platform for your project# platform :ios, '9.0'target 'FlutterLearnMix' do # Uncomment the next line if you're using Swift or would like to use dynamic frameworks # use_frameworks! #绝对路径# flutter_application_path = '/Users/himin/Desktop/Web/FlutterProject/flutter_learn_mix/Flutter/flutter_module/' #相对路径 flutter_application_path = '../../Flutter/flutter_module/' eval(File.read(File.join(flutter_application_path, '.ios', 'Flutter', 'podhelper.rb')), binding)end 5. 在ios工程里添加运行脚本：iOS工程中Build Phases -&gt; Run Script添加如下脚本，如果Run Script不存在，点击加号创建即可，并且确保Run Script这一行在 “Target dependencies”后面。(flutter文档上说有这一步，个人实际测试发现不加也可以，貌似并没有执行) 12&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot; build&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot; embed 6. iOS工程中加入代码来使用FlutterViewController： ① AppDelegate.h文件中: 123456#import &lt;UIKit/UIKit.h&gt;#import &lt;Flutter/Flutter.h&gt;@interface AppDelegate : FlutterAppDelegate@property (nonatomic,strong) FlutterEngine *flutterEngine;@end ② AppDelegate.m文件中: 1234567891011121314151617181920212223242526#import &quot;AppDelegate.h&quot;#import &quot;ViewController.h&quot;#import &lt;FlutterPluginRegistrant/GeneratedPluginRegistrant.h&gt;@interface AppDelegate ()@end@implementation AppDelegate// This override can be omitted if you do not have any Flutter Plugins.- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { self.flutterEngine = [[FlutterEngine alloc] initWithName:@&quot;io.flutter&quot; project:nil]; [self.flutterEngine runWithEntrypoint:nil]; [GeneratedPluginRegistrant registerWithRegistry:self.flutterEngine]; self.window = [[UIWindow alloc] initWithFrame:UIScreen.mainScreen.bounds]; ViewController *vc = [[ViewController alloc] init]; UINavigationController *navVC = [[UINavigationController alloc] initWithRootViewController:vc]; self.window.rootViewController = navVC; [self.window makeKeyAndVisible]; return [super application:application didFinishLaunchingWithOptions:launchOptions];}@end ③ *ViewController.m文件中: 12345678910111213141516171819202122232425262728293031323334#import &quot;ViewController.h&quot;#import &lt;Flutter/Flutter.h&gt;#import &quot;AppDelegate.h&quot;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = UIColor.whiteColor; { UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(20, 80, 100, 30)]; btn.backgroundColor = UIColor.orangeColor; [btn setTitle:@&quot;push&quot; forState:UIControlStateNormal]; [btn setTitleColor:UIColor.grayColor forState:UIControlStateNormal]; [btn addTarget:self action:@selector(pushBtnClick) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; }}- (void)pushBtnClick { NSLog(@&quot;push to flutter&quot;); FlutterEngine *flutterEngine = [(AppDelegate *)[UIApplication sharedApplication].delegate flutterEngine]; FlutterViewController *flutterViewController = [[FlutterViewController alloc] initWithEngine:flutterEngine nibName:nil bundle:nil]; flutterViewController.view.backgroundColor = UIColor.whiteColor; NSAssert([self navigationController], @&quot;Must have a NaviationController&quot;); [[self navigationController] pushViewController:flutterViewController animated:YES];} 7. 然后编译运行程序，点击push按钮跳转到flutter页面8. flutter工程热重载：切换到FlutterLearnMix/Flutter/flutter_module目录，执行flutter attach即可，修改后保存然后命令行输入’r’即可实现热重载","link":"/exclude/iOS/FlutterMix_iOS.html"},{"title":"KVO","text":"KVO机制依赖于runtime动态能力，如果一个类型为A的类被添加了观察，系统会生成一个NSKVONotifying_A的类，并将对象的isa指针指向新的类，新生成的类会重写以下方法： setter：添加观察方法 class: ( 修改了isa指向后，class返回的值不会变，但isa的值会变 ) dealloc: 释放资源 _isKVOA: 用来标识该类是一个KVO机制生成的类 使用① 添加观察者 12345678// 添加观察者addObserver:&lt;#(nonnull NSObject *)#&gt; forKeyPath:&lt;#(nonnull NSString *)#&gt; options:&lt;#(NSKeyValueObservingOptions)#&gt; context:&lt;#(nullable void *)#&gt;options: KVO的一些属性设值，会影响change字典，可选值如下：NSKeyValueObservingOptionNew change字典包括改变后的值 NSKeyValueObservingOptionOld change字典包括改变前的值NSKeyValueObservingOptionInitial 注册后立即触发KVO通知NSKeyValueObservingOptionPrior 值改变前是否也要通知（这个key决定了是否在改变前改变后通知两次） ② 实现观察响应方法 12// 实现观察响应方法- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context ③ 移除观察者 12// 移除观察者removeObserver:&lt;#(nonnull NSObject *)#&gt; forKeyPath:&lt;#(nonnull NSString *)#&gt; 优点 1.使用简单，只需三步完成； 2.当被观察者的对象的属性发生改变时，自动通知相应的观察者了; 缺点 1.只能用来对对象的属性作出反应，而不会用来对方法或者动作作出反应； 2.观察的属性必须使用string来定义，编译器不会检测，容易出错； KVO的实现是对注册的keypath中自动实现了两个函数，在setter方法中自动调用： 12- (void)willChangeValueForKey:(NSString *)key- (void)didChangeValueForKey:(NSString *)key 手动KVO① 手动实现属性的setter方法，并在设置操作的前后分别调用 12345678910111213141516171819202122- (void)willChangeValueForKey:(NSString *)key- (void)didChangeValueForKey:(NSString *)key, 这两个方法用于通知系统该key的属性值即将和已经改变了@Interface People: NSObject { int _age;}- (void)setAge: (int)age;- (int)age;@end@implementation People- (void)setAge: (int)age { [self willChangeValueForKey:@“age”]; _age = age; [self didChangeValueForKey:@“age”];}- (int)age { return _age;}@end ② 实现类方法 + (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key 12345678910111213141516171819@implementation People- (void)setAge: (int)age { [self willChangeValueForKey:@“age”]; _age = age; [self didChangeValueForKey:@“age”];}- (int)age { return _age;}+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key { if([key isEqualToString:@“age”]) { return NO; } return [super automaticallyNotifiesObserversForKey:key];// 非手动实现的key 需要交给super处理}@end 禁用KVO1+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)key; 方法中返回NO; 键值观察依赖键12345① 手动实现setter和getter方法② 实现 + (NSSet *)keyPathsForValuesAffectingName; 或者 + (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key;( 实现此方法需要先获取super返回的结果，然后判断key是不是目标key,如果是就将依赖属性的keypath添加到super返回的NSSet结果中，否则直接返回super的结果 )","link":"/exclude/iOS/KVO.html"},{"title":"iOS 系统各种权限判断","text":"iOS 系统各种权限判断1234567891011121314151617181920212223242526@interface LEMSystemAuthorization : NSObject// 相机权限+ (BOOL)hasCameraAuthorization;// 相册权限+ (BOOL)hasPhotoLibraryAuthorization;// 通知权限+ (BOOL)hasNotificationAuthorization;// 网络权限+ (BOOL)hasNetWorkAuthorization;// 麦克风权限+ (BOOL)hasMicrophoneAuthorization;// 定位权限+ (BOOL)hasLocationAuthorization;// 通讯录权限+ (BOOL)hasAddressBookAuthorization;// 日历权限+ (BOOL)hasCalendarAuthorization;// 备忘录权限+ (BOOL)hasMemorandumAuthorization;// 提醒事项权限+ (BOOL)hasReminderAuthorization;// 后台应用刷新权限 运动与健身权限 语音识别@end 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#import &quot;LEMSystemAuthorization.h&quot;#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;Photos/Photos.h&gt;#import &lt;AssetsLibrary/AssetsLibrary.h&gt;#import &lt;UserNotifications/UserNotifications.h&gt;//@import CoreTelephony;#import &lt;AddressBook/AddressBook.h&gt;#import &lt;Contacts/Contacts.h&gt;#import &lt;CoreLocation/CoreLocation.h&gt;#import &lt;EventKit/EventKit.h&gt;//手机系统版本号#define pSystemVersion [[[UIDevice currentDevice] systemVersion] floatValue]@implementation LEMSystemAuthorization// 相机权限+ (BOOL)hasCameraAuthorization { AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; if (authStatus == AVAuthorizationStatusDenied || authStatus == AVAuthorizationStatusRestricted) { return NO; } return YES;}// 相册权限+ (BOOL)hasPhotoLibraryAuthorization {// if (pSystemVersion &gt; 8.0) { PHAuthorizationStatus authStatus = [PHPhotoLibrary authorizationStatus]; if (authStatus == PHAuthorizationStatusRestricted || authStatus == PHAuthorizationStatusDenied) { return NO; }// } else {// ALAuthorizationStatus authStatus = [ALAssetsLibrary authorizationStatus];// if (authStatus == ALAuthorizationStatusRestricted || authStatus == ALAuthorizationStatusDenied) {// return NO;// }// return YES;// } return YES;}// 通知权限+ (BOOL)hasNotificationAuthorization { UIUserNotificationSettings *setting = [[UIApplication sharedApplication] currentUserNotificationSettings]; if (UIUserNotificationTypeNone == setting.types) { return NO; } return YES;}// 网络权限+ (BOOL)hasNetWorkAuthorization {// CTCellularData *cellularData = [[CTCellularData alloc]init];// CTCellularDataRestrictedState state = cellularData.restrictedState;//// NSLog(@&quot;network status == %zu&quot;, state);//// if (state == kCTCellularDataRestricted) {// return NO;// }// return YES; return NO;}// 麦克风权限+ (BOOL)hasMicrophoneAuthorization { AVAuthorizationStatus authStatus = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeAudio]; if (authStatus == AVAuthorizationStatusDenied || authStatus == AVAuthorizationStatusRestricted) { return NO; } return YES;}// 定位权限+ (BOOL)hasLocationAuthorization { BOOL isLocationEnabled = [CLLocationManager locationServicesEnabled]; if (!isLocationEnabled) { CLAuthorizationStatus authStatus = [CLLocationManager authorizationStatus]; if (authStatus == kCLAuthorizationStatusDenied || authStatus == kCLAuthorizationStatusRestricted) { return NO; } } return YES;}// 通讯录权限+ (BOOL)hasAddressBookAuthorization { if (pSystemVersion &gt;= 9.0) { CNAuthorizationStatus status = [CNContactStore authorizationStatusForEntityType:CNEntityTypeContacts]; if (status == CNAuthorizationStatusDenied || status == CNAuthorizationStatusRestricted) { return NO; } } else { ABAuthorizationStatus authStatus = ABAddressBookGetAuthorizationStatus(); if (authStatus == kABAuthorizationStatusDenied || authStatus == kABAuthorizationStatusRestricted) { return NO; } } return YES;}// 日历权限+ (BOOL)hasCalendarAuthorization { EKAuthorizationStatus authStatus = [EKEventStore authorizationStatusForEntityType:EKEntityTypeEvent]; if (authStatus == EKAuthorizationStatusDenied || authStatus == EKAuthorizationStatusRestricted) { return NO; } return YES;}// 备忘录权限+ (BOOL)hasMemorandumAuthorization { return NO;}// 提醒事项权限+ (BOOL)hasReminderAuthorization { EKAuthorizationStatus authStatus = [EKEventStore authorizationStatusForEntityType:EKEntityTypeReminder]; if (authStatus == EKAuthorizationStatusDenied || authStatus == EKAuthorizationStatusRestricted) { return NO; } return YES;}@end","link":"/exclude/iOS/SystemAuthorization.html"},{"title":"iOS 常用宏","text":"iOS 常用宏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243#ifndef LEMBase_h#define LEMBase_h#pragma mark - 是否为空// 字符串是否为空#define kStringIsEmpty(str) ([str isKindOfClass:[NSNull class]] || str == nil || [str length] &lt; 1 ? YES : NO)// 数组是否为空#define kArrayIsEmpty(array) (array == nil || [array isKindOfClass:[NSNull class]] || array.count == 0)// 字典是否为空#define kDictIsEmpty(dic) (dic == nil || [dic isKindOfClass:[NSNull class]] || dic.allKeys == 0)// 是否是空对象#define kObjectIsEmpty(_object) (_object == nil \\|| [_object isKindOfClass:[NSNull class]] \\|| ([_object respondsToSelector:@selector(length)] &amp;&amp; [(NSData *)_object length] == 0) \\|| ([_object respondsToSelector:@selector(count)] &amp;&amp; [(NSArray *)_object count] == 0))#pragma mark - 屏幕宽度与高度、导航栏、TabBar、设备、适配// 屏宽#define kMainWidth \\([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? [UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale : [UIScreen mainScreen].bounds.size.width)// 屏高#define kMainHeight \\([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? [UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale : [UIScreen mainScreen].bounds.size.height)// 屏的size(宽、高)#define kMainSize \\([[UIScreen mainScreen] respondsToSelector:@selector(nativeBounds)] ? CGSizeMake([UIScreen mainScreen].nativeBounds.size.width/[UIScreen mainScreen].nativeScale,[UIScreen mainScreen].nativeBounds.size.height/[UIScreen mainScreen].nativeScale) : [UIScreen mainScreen].bounds.size)// 判断是否为iPhone#define kIsIPhone (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)// 判断是否为iPad#define kIsIPad (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)// 屏幕宽高#define kScreenBounds ([[UIScreen mainScreen] bounds])#define kScreenWidth ([[UIScreen mainScreen] bounds].size.width)#define kScreenHeight ([[UIScreen mainScreen] bounds].size.height)#define kScreenMaxLength (MAX(kScreenWidth, kScreenHeight))#define kScreenMinLength (MIN(kScreenWidth, kScreenHeight))// iphone型号：4、5、6(6/7/8)、plus、X(X/XS)、XR(XR/XSMax)#define kIsIPhone4OrLess (kIsIPhone &amp;&amp; kScreenMaxLength &lt; 568.0)#define kIsIPhone5 (kIsIPhone &amp;&amp; kScreenMaxLength == 568.0)#define kIsIPhone6 (kIsIPhone &amp;&amp; kScreenMaxLength == 667.0)#define kIsIPhonePLUS (kIsIPhone &amp;&amp; kScreenMaxLength == 736.0)#define kIsIPhoneX (kIsIPhone &amp;&amp; kScreenWidth == 375.0f &amp;&amp; kScreenHeight == 812.0f) // X/XS#define kIsIPhoneXR (kIsIPhone &amp;&amp; kScreenWidth == 414.0f &amp;&amp; kScreenHeight == 896.0f) // XR/XSMax#define kIsFullScreen (kIsIPhoneX || kIsIPhoneXR) // X/XS/XR/XSMax 全面屏系列// 底部 安全高度 (iPhoneX)#define kBottomSafeHeight (kIsFullScreen ? 34 : 0)// 系统 手势高度 (iPhoneX)#define kSystemGestureHeight (kIsFullScreen ? 13 : 0)// TabBar高度#define kTabBarHeight (49 + kBottomSafeHeight)// 状态栏高度#define kStatusBarHeight (kIsFullScreen ? 44 : 20)// 导航栏高度#define kNavBarHeight 44// 导航栏+状态栏高度#define kNavAndStatusBarHeight (kStatusBarHeight + kNavBarHeight)// 适配 320/568 375/667 414/736#define kAutoLayoutWidth(w) (kScreenWidth/375 * w)#define kAutoLayoutHeigth(h) (kScreenHeight/667 * h)#pragma mark - 版本号、当前语言// APP版本号#define kAppVersion [[[NSBundle mainBundle] infoDictionary] objectForKey:@&quot;CFBundleShortVersionString&quot;]// 系统版本号#define kSystemVersion [[[UIDevice currentDevice] systemVersion] floatValue]// 获取当前语言#define kCurrentLanguage ([[NSLocale preferredLanguages] objectAtIndex:0])// 检测用户系统版本号#define kiOS12 (kSystemVersion &gt;= 12.0)#define kiOS11 (kSystemVersion &gt;= 11.0 &amp;&amp; kSystemVersion &lt; 12.0)#define kiOS10 (kSystemVersion &gt;= 10.0 &amp;&amp; kSystemVersion &lt; 11.0)#define kiOS9 (kSystemVersion &gt;= 9.0 &amp;&amp; kSystemVersion &lt; 10.0)#define kiOS8 (kSystemVersion &gt;= 8.0 &amp;&amp; kSystemVersion &lt; 9.0)#define kiOS12Later (kSystemVersion &gt;= 12.0)#define kiOS11Later (kSystemVersion &gt;= 11.0)#define kiOS10Later (kSystemVersion &gt;= 10.0)#define kiOS9Later (kSystemVersion &gt;= 9.0)#define kiOS8Later (kSystemVersion &gt;= 8.0)#pragma mark - 单例// 定义#define DEF_SINGLETON + (instancetype)sharedInstance;// 实现#define IMP_SINGLETON \\+ (instancetype)sharedInstance { \\static id sharedObject = nil; \\static dispatch_once_t onceToken; \\dispatch_once(&amp;onceToken, ^{ \\sharedObject = [[self alloc] init]; \\}); \\return sharedObject; \\}\\- (id)copyWithZone:(NSZone*)zone{\\return self;\\}#pragma mark - 一些常用的缩写：// APP对象（单例对象）#define kApplication [UIApplication sharedApplication]// 主窗口（keyWindow）#define kKeyWindow [UIApplication sharedApplication].keyWindow// APP对象的delegate#define kAppDelegate [UIApplication sharedApplication].delegate// NSUserDefaults实例化#define kUserDefaults [NSUserDefaults standardUserDefaults]// 通知中心（单例对象）#define kNotificationCenter [NSNotificationCenter defaultCenter]#pragma mark - NSUserDefaults// NSUserDefaults set/get/remove#define NSUserDefaultsSet(obj,key) \\[kUserDefaults setObject:obj forKey:key]; \\[kUserDefaults synchronize]#define NSUserDefaultsGet(key) [kUserDefaults objectForKey:key]#define NSUserDefaultsRemove(key) [kUserDefaults removeObjectForKey:key]#pragma mark - 沙盒路径// 获取沙盒的Document路径#define kDocumentPath [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]// 获取沙盒的temp路径#define kTempPath NSTemporaryDirectory()// 获取沙盒的Cache路径#define kCachePath [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]#pragma mark - DEBUG// 开发的时候打印，但是发布的时候不打印的NSLog#ifdef DEBUG#define DLog(fmt, ...) NSLog((@&quot;%s [Line %d]\\n&quot; fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__);#else#define DLog(...)#define NSLog(...)#endif#pragma mark - 颜色color、图片image、字体font// RGB格式#define kRGBColor(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1.0]// RGBA格式 （A：alpha）#define kRGBAColor(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(r)/255.0 blue:(r)/255.0 alpha:a]// 随机色生成#define kRandomColor KRGBColor(arc4random_uniform(256)/255.0,arc4random_uniform(256)/255.0,arc4random_uniform(256)/255.0)// 16进制形式#define kColorWithHex(rgbValue) \\[UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16)) / 255.0 \\green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8)) / 255.0 \\blue:((float)(rgbValue &amp; 0xFF)) / 255.0 alpha:1.0]// 清除背景色#define kClearColor [UIColor clearColor]// 背景色#define kBgColor [UIColor colorWithRed:242.0/255.0 green:236.0/255.0 blue:231.0/255.0 alpha:1.0]// 读取本地图片#define kLoadImage(file,ext) [UIImage imageWithContentsOfFile:[[NSBundle mainBundle] pathForResource:file ofType:ext]]// 定义UIImage对象（路径）#define kImage(name) [UIImage imageWithContentsOfFile:[[NSBundle mainBundle] pathForResource:name ofType:nil]]// 定义UIImage对象#define kImageName(str) [UIImage imageNamed:str inBundle:[NSBundle bundleForClass:[self class]] compatibleWithTraitCollection:nil]// 字体#define kSystemFontLight(s) [UIFont systemFontOfSize:s]#define kSystemFontBold(s) [UIFont boldSystemFontOfSize:s]#define kPingFangFontLight(s) (kiOS9Later ? [UIFont fontWithName:@&quot;PingFangSC-Light&quot; size:s] : kSystemFontLight(s))#define kPingFangFontRegular(s) (kiOS9Later ? [UIFont fontWithName:@&quot;PingFangSC-Regular&quot; size:s] : kSystemFontLight(s))#define kPingFangFontBold(s) (kiOS9Later ? [UIFont fontWithName:@&quot;PingFangSC-Medium&quot; size:s] : kSystemFontBold(s))#pragma mark - 弱引用/强引用// 弱引用/强引用#define kWeakSelf(type) __weak typeof(type) weak##type = type;#define kStrongSelf(type) __strong typeof(type) type = weak##type;/** Synthsize a weak or strong reference. Example: @weakify(self) [self doSomething^{ @strongify(self) if (!self) return; ... }]; */#ifndef weakify #if DEBUG #if __has_feature(objc_arc) #define weakify(object) autoreleasepool{} __weak __typeof__(object) weak##_##object = object; #else #define weakify(object) autoreleasepool{} __block __typeof__(object) block##_##object = object; #endif #else #if __has_feature(objc_arc) #define weakify(object) try{} @finally{} {} __weak __typeof__(object) weak##_##object = object; #else #define weakify(object) try{} @finally{} {} __block __typeof__(object) block##_##object = object; #endif #endif#endif#ifndef strongify #if DEBUG #if __has_feature(objc_arc) #define strongify(object) autoreleasepool{} __typeof__(object) object = weak##_##object; #else #define strongify(object) autoreleasepool{} __typeof__(object) object = block##_##object; #endif #else #if __has_feature(objc_arc) #define strongify(object) try{} @finally{} __typeof__(object) object = weak##_##object; #else #define strongify(object) try{} @finally{} __typeof__(object) object = block##_##object; #endif #endif#endif#pragma mark - 角度/弧度// 由角度转换为弧度#define kDegreesToRadian(x) (M_PI * (x) / 180.0)// 由弧度转换为角度#define kRadianToDegrees(radian) (radian * 180.0) / (M_PI)#pragma mark - 获取一段时间间隔// 获取一段时间间隔#define kStartTime CFAbsoluteTime start = CFAbsoluteTimeGetCurrent();#define kEndTime NSLog(@&quot;Time: %f&quot;, CFAbsoluteTimeGetCurrent() - start)#endif","link":"/exclude/iOS/iOSMacro.html"},{"title":"iOS知识点总结（一）","text":"iOS知识点总结（一）目录[[toc]] 多线程中的通知操作在多线程程序中，通知总是在发送通知者的线程中调用 ( 通知观察者的被调函数总是运行在发送通知者的线程中 )。通知的被调函数不一定运行在主线程中，如果需要做UI相关操作，需要手动切换到主线程。 OC中创建线程的方法1. NSThread 12[NSThread detachNewThreadSelector:toTarget:withObject];[NSThread alloc] initWithTarget:selector:object]; -&gt; [thread start]; 这两种方式的区别是：前一种一调用就会立即创建一个线程来做事情；而后一种虽然你 alloc 了也 init了，但是要直到我们手动调用 start 启动线程时才会真正去创建线程。 NSObject方法： 1[self performSelectorOnBackground:withObject]; 2. GCD 12dispath_async(dispatch_get_global_queue(0,0),^{}); 3. NSOperation 1[[[NSOperationQueue alloc] init] addOperation:]; 主线程中执行代码的方法 123① [self performSelectorOnMainThread:withObject:];② dispatch_async(dispatch_get_main_queue(),^{});③ [[NSOperation mainQueue] addOperation:]; OC反射机制定义:运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法；这种动态获取属性以及动态调用对象的方法的功能就是反射机制. 获取class，检查继承关系，动态的调用方法 Class对象的获取：Class对象的本质是一个结构体，这个结构体中的成员变量还是自己。使用[self class] 或者使用[类名 class] 系统Foundation框架提供了一些方法反射的API，可以通过这些API将字符串转化为SEL、class、protocol等，由于OC语言的动态性，这些操作都发生在运行时 反射方法： SEL123SEL *selector = NSSelectorFromString(@“setName”);[obj performSelector: selector withObject:@“Himin”];(objc_msgSend)NSStringFromSelector(@selector(setName:)) Class12NSString *NSStringFromClass(Class aClass);Class *NSClassFromString(NSString *aClassName); Protocol12NSString *NSStringFromProtocol(Protocol *proto);Protocol *NSProtocolFromString(NSString *namestr); 常用的判断方法：12345678910111213isKindOfClassisMemberOfClassconfirmToProtocolrespondsToSelector// 当前对象是否这个类或其子类的实例 - (BOOL)isKindOfClass:(Class)aClass; // 当前对象是否是这个类的实例 - (BOOL)isMemberOfClass:(Class)aClass; // 当前对象是否遵守这个协议 - (BOOL)conformsToProtocol:(Protocol *)aProtocol; // 当前对象是否实现这个方法 - (BOOL)respondsToSelector:(SEL)aSelector; Swift static和class声明一个静态属性或者函数，你可以使用关键字static来修饰值类型。以下是一个结构体的例子： 123struct Sun { static func illuminate() {}} 对于类来说，你可以使用static或者class修饰符。虽然它们完成同样的功能，但实际上是不同的。你能解释一下它们之间有什么不同吗？答案:使用static关键字，静态属性和静态函数是不能被重写的，但当使用class关键字，你可以重写属性和函数。其实，对于类来说，static关键字是class final的别名而已。例如，你编译下面这些code时，当你要重写illuminate()函数时，编译器提示错误： 123456789101112class Star { class func spin() {} static func illuminate() {}}class Sun : Star { override class func spin() { super.spin() } override static func illuminate() { // error: class method overrides a 'final' class method super.illuminate() }} iOS instancetype和id的区别 instancetype在类型表示上，跟id一样，可以表示任何对象类型 instancetype只能用在返回值类型上，不能像id一样用在参数类型上 instancetype比id多一个好处：编译器会检测instancetype的真实类型 loadView 与 viewDidLoadloadView 当用到控制器view时，会调用控制器view的get方法，首先判断view是否已被创建，如果存在直接返回，不存在则调用loadview方法创建 viewDidLoad 当控制器的loadview执行完毕，view被创建成功后会调用viewDidLoad方法 loadView 与 viewDidLoad在控制器未被销毁的情况下可能会被执行多次： 比如A控制器push出B控制器，此时显示的是B控制器的view,若在此时收到内存警告，一般会销毁掉A控制器中一些无用的变量以及view,当B控制器pop到A控制器的时候，会重新调用A控制器的loadView和viewDidLoad方法 补充: ① storyboard加载的是控制器以及控制器的view,而xib加载的仅仅是控制器的view ② 控制器view的生命周期viewDidLoad -&gt; viewWillAppear -&gt; viewWillLayoutSubviews -&gt; viewDidLayoutSubviews -&gt; viewDidAppear-&gt; viewWillDisappear -&gt; viewDidDisappear ③ 内存警告传递过程手机内存不足产生事件 -&gt; 通知应用程序 -&gt; 调用应用程序代理方法 -&gt; 把事件传递给窗口 -&gt; 窗口传递给控制器 -&gt; 调用控制器的内存警告方法 ④ xib描述控制器view时，其File’s Owner为对应的控制器，当通过xib自定义view或自定义cell时，File’s Owner不能填写自定义view或者cell的类名 KVC通过key值直接访问对象的属性，或者给对象的属性赋值，而不需要明确的调用存取方法。可以在运行时动态的访问和修改对象的属性，而不是在编译时确定 动态的取值和设值 使用KVC来访问和修改私有变量 Model和字典转换 修改一些控件的内部属性，如：1234// placeholderLabel的颜色以及字体大小：static NSString * const WDDPlaceholderColorkeyPath = @&quot;_placeholderLabel.textColor&quot;;static NSString * const WDDPlaceholderFontPath = @&quot;_placeholderLabel.font&quot;;[self setValue:self.placeholderHighlightedFont forKeyPath:WDDPlaceholderFontPath]; 操作集合 用KVC实现高阶消息传递 实现KVO UIButton文字居左显示12345678910111213141516// how to position content hozontally inside control. default is center@property(nonatomic) UIControlContentHorizontalAlignment contentHorizontalAlignment; typedef NS_ENUM(NSInteger, UIControlContentHorizontalAlignment) { UIControlContentHorizontalAlignmentCenter = 0, UIControlContentHorizontalAlignmentLeft = 1, UIControlContentHorizontalAlignmentRight = 2, UIControlContentHorizontalAlignmentFill = 3,};// 设置contentHorizontalAlignmentbutton.contentHorizontalAlignment = UIControlContentHorizontalAlignmentLeft;// 如果感觉太靠边了，可以设置UIButton的titleEdgeInsets属性，这样button的title就距左边10个像素的距离。button.titleEdgeInsets = UIEdgeInsetsMake(0, 10, 0, 0);// 居右显示：button.contentHorizontalAlignment = UIControlContentHorizontalAlignmentRight; http请求几种方式 HEAD 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 GET 向特定的资源发出请求。注意：GET方法不应当被用于产生“副作用”的操作中，例如在web app.中。其中一个原因是GET可能会被网络蜘蛛等随意访问。 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 PUT 向指定资源位置上传其最新内容。 DELETE 请求服务器删除Request-URI所标识的资源。 TRACE 回显服务器收到的请求，主要用于测试或诊断。 CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 OPTIONS 返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送’*’的请求来测试服务器的功能性。ios 多线程——原子、非原子，自旋锁和互斥锁 atomic 和 nonatomic nonatomic：非原子属性，线程不安全的，效率高。 atomic：原子属性，线程安全的，效率相对低。 原子属性是一种单(线程)写多(线程)读的多线程技术。 atomic属性内部的锁称为自旋锁，凡是线程安全的对象，内部肯定会加锁。 自旋锁和互斥锁 相同点 都能保证同一时间只有一个线程访问共享资源。都能保证线程安全。 不同点 互斥锁：如果共享数据已经有其他线程加锁了，线程会进入休眠状态等待锁。一旦被访问的资源被解锁，则等待资源的线程会被唤醒。 自旋锁：如果共享数据已经有其他线程加锁了，线程会以死循环的方式等待锁，一旦被访问的资源被解锁，则等待资源的线程会立即执行。 （ 自旋锁的效率高于互斥锁 ） iOS 多线程解决方案pthread，NSThread，GCD，NSOperation RunLoop系统默认注册了5个mode 12345kCFRunLoopDefaultMode //App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode //界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响UIInitializationRunLoopMode // 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用GSEventReceiveRunLoopMode // 接受系统事件的内部 Mode，通常用不到kCFRunLoopCommonModes //这是一个占位用的Mode，不是一种真正的Mode View和LayerUIView 主要是对显示内容的管理，可以响应事件 CALayer 主要侧重显示内容的绘制，不能响应事件 内存泄漏 循环引用：delegate,block,NSTimer 非OC对象的处理 地图相关类：使用完毕时将地图、代理等滞空为nil，注意地图中标注（大头针）的复用，并且在使用完毕时清空标注数组 大次数循环内存暴涨 内存管理之引用计数式内存管理的思考方式① 自己生成的对象，自己所持有② 非自己生成的对象，自己也能持有③ 不再需要自己持有的对象时释放④ 非自己持有的对象自己不能释放 iOS核心动画keypath transform.rotation：旋转动画 transform.rotation.x：按x轴旋转动画 transform.rotation.y：按y轴旋转动画 transform.rotation.z：按z轴旋转动画 transform.scale：按比例放大缩小动画 transform.scale.x：在x轴按比例放大缩小动画 transform.scale.y：在y轴按比例放大缩小动画 transform.scale.z：在z轴按比例放大缩小动画 position：移动位置动画 opacity：透明度动画 strokeEnd :颜色从无到有 strokeStart :颜色从有到无 总结一下什么时候会触发layoutSubviews init初始化不会触发layoutSubviews addSubview会触发layoutSubviews 设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化 滚动一个UIScrollView会触发layoutSubviews 旋转Screen会触发父UIView上的layoutSubviews事件 改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件 AFNetworking的大体结构 我们封装一个网络框架，首先需要一个类来检测当前网络环境（AFNetworkReachabilityManager）:AFN提供了四种网络状态–未知、蜂窝、wifi、无网络。如果网络环境发生了改变，需要及时进行通知。 我们需要封装一个类来提供安全策略（AFSecurityPolicy）：AFN提供了三种安全策略–公钥、证书、无。 我们需要封装一个类来提供请求序列化（AFURLRequestSerialization）：缓存策略、cookie使用、超时时间、请求头处理等，并根据不同条件返回请求实例。 我们需要封装一个类来提供响应序列化(AFURLResponseSerialization)：可接受的状态码、可接受的Content-Type类型、是否有效的响应，实例化响应实例。处理json、xml和其他潜在类型的类。 我们需要封装一个类(AFURLSessionManager)，将上面的四个类进行应用，并提供网络会话及相关操作。 为了更好的进行HTTP的细节处理，提供子类(AFHTTPSessionManager)，分别用来处理GET、POST、HEAD、PUT、PATCH、DELET方法。","link":"/exclude/iOS/ios_summary_1.html"},{"title":"RunLoop","text":"RunLoop系统默认注册了5个mode 12345kCFRunLoopDefaultMode //App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode //界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响UIInitializationRunLoopMode // 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用GSEventReceiveRunLoopMode // 接受系统事件的内部 Mode，通常用不到kCFRunLoopCommonModes //这是一个占位用的Mode，不是一种真正的Mode","link":"/exclude/iOS/runloop.html"},{"title":"wifi 名称获取","text":"wifi 名称获取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#import &quot;ViewController.h&quot;#import &lt;SystemConfiguration/CaptiveNetwork.h&gt;@interface ViewController ()@property (nonatomic, strong) AFNetworkReachabilityManager *manager;@end@implementation ViewController- (void)dealloc { [self.manager stopMonitoring];}- (void)viewDidLoad { [super viewDidLoad]; { UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(40, 140, 100, 40)]; btn.layer.backgroundColor = UIColor.orangeColor.CGColor; [btn setTitle:@&quot;test&quot; forState:UIControlStateNormal]; [btn addTarget:self action:@selector(btnClick) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; }}- (void)btnClick { CFArrayRef wifis = CNCopySupportedInterfaces(); if (!wifis || CFArrayGetCount(wifis) == 0) { return; } NSArray *interfaces = (__bridge_transfer NSArray *)(wifis); NSDictionary *info = nil; for (NSString *name in interfaces) { info = (__bridge_transfer NSDictionary *)CNCopyCurrentNetworkInfo((__bridge CFStringRef)name); } if (!info) { return; } NSString *ssid = info[@&quot;SSID&quot;]; NSString *bssid = info[@&quot;BSSID&quot;]; NSLog(@&quot;\\nwifi name: %@\\nwifi mac address: %@&quot;, ssid, bssid);}@end","link":"/exclude/iOS/wifiNameAccess.html"},{"title":"Movie","text":"昨日青空12345678910你要记住，只要有自己真心喜欢的东西，就会发出光来，喜欢一个人，也是一样，即便到最后不能在一起，也没有关系，因为，你一定会喜欢，那个因为喜欢着他而发光的自己。","link":"/exclude/essay/Movie/m1.html"},{"title":"我会记得你，然后爱别人","text":"愿你的生活，春有百花秋有月，夏有凉风冬有雪。 &emsp;&emsp;—— 这是一个有温度的故事 ::: tip 关于爱情所有的爱情都是以互相吸引为原则，无伦是男是女，长得好看是主要的条件之一，很多人的爱情之所以坎坷，就是因为不够漂亮，人生就像下棋，因为落棋无悔，所以处处惊心。::: ::: tip 关于爱情在爱情里，如果一个人对另外一个人没有感觉，那就不要让对方抱有任何希望。::: &emsp;&emsp;有些时候，人就是这样，在一起的时候不珍惜，总想着如何摆脱对方，可真发现无法再拥有对方，不管以任何身份都无法再接近的时候，才会后悔。可时光是无法重来的东西，有些遗憾，就因为遗憾才显得重要。 序若有深情藏于心，岁月从不伤良人。 &emsp;&emsp;人们总是习惯去问故事的真假，却从不问生活的残酷。我们都喜欢圆满的结局，比如相爱多年终成眷属，比如千里奔赴终成正果。我们总希望付出了就有回报，相爱了就一定要圆满。电影里一个字幕，能转眼数年，可在生活里，却是活生生的日子。一句“好聚好散”不知道要用多少难以入眠的日子来填充，一句“好久不见”不知道要用多少独自等待来偿还。 &emsp;&emsp;只要活在世间，每个人心里的故事都足以拍成一部电影，而每个人的电影结局都不会相同。除了自己以外，别人都无法感同身受。除了你以外，也再没有人能爱得这么疯狂。 &emsp;&emsp;看故事的时候，别问真假；喝酒的时候，别问过往。你信它，它就是真的，你不信，一切都是假的。就像你曾经相信爱情，虽然受过它的伤害，但别人问起你，你也不会否认爱情存在过。 &emsp;&emsp;那些你未曾到过的地方，不代表不存在；那些你没经历过的事情，不代表没发生。就像你没遇见爱情之前，你不能否认那个对的人会出现，而你也不能因为现在的困难，否定你以后的幸福。 &emsp;&emsp;生活真的很难，但它仍值得我们去为之奋斗。爱情真的很辛苦，但每个人都在爱情的路上结伴而行。认识一个人很容易，但忘记一个人却要搭上半生时间。 &emsp;&emsp;我们就像站在蛋糕店外面的孩子，觉得橱窗里的蛋糕每一块儿都很漂亮，每一块儿都很好吃。所以我们不停地努力奋斗赚钱，就是为了有朝一日能吃到那个最漂亮的蛋糕。 &emsp;&emsp;我们不停地试吃，总觉得下一个会更好，于是扔掉了手里那块儿来之不易的蛋糕。后来很多人都倦了，觉得蛋糕不过如此，也许隔壁那家中餐馆也不错……我们就这样一路前行，一路错过，总以为有更好的在不远处。其实我们最开始拿在手里的那个，才是自己最想要的。 &emsp;&emsp;恋爱就像捉迷藏，每个人都含蓄地把自己的感情藏在心里，两个人来来回回地绕圈子，彼此含情脉脉，觉得激情永远耗不完，觉得喜欢永远都在。 &emsp;&emsp;可后来就不一样了。恋爱就像两个人拽皮筋儿，双方各自伸出一只手，松得慢的一方就会受伤。大家都习惯有问题就飞速地脱身，怕自己受到伤害。久而久之，激情耗完了，喜欢不在了。 &emsp;&emsp;如此，我们就不再相爱不再生活了吗？当然不是！每一个心里藏着故事的人的生命中，都有一个难以割舍的人存在。那个人就像信仰一样存在心里，明知永远无法有交集，但放在心里就是暖的，就像这本书的名字一样：《我会记得你，然后爱别人》。 &emsp;&emsp;也许你和你的所爱，此时正隔着人山人海…… &emsp;&emsp;但请你相信，良人自有一双脚，隔山隔海会归来。 我的故事你的酒山南，水北沈山南相信，山水有相逢，终会再相见。 – 一个没有尽头的等待。 &emsp;&emsp;这就是爱情最让人无法理解的部分，每个人都会遇见这么一个主儿，对你不冷不热，漠不关心。但你就是控制不住自己对这个人好，甭管这个人对你什么态度，你就是一门心思想对人家好。山南对水北就是这般，很多朋友从最开始的理解，到变成不解，最后变成了无奈。 南城浮生人生如草木，有人过眼即忘，有人终身难舍。 – 也许是女孩刚开始的那些话让男孩望而却步，女孩对男孩说不要喜欢她，如果当初女孩刚开始没有说那些话，也许他们会过得很幸福；可惜，没有如果；失去了之后才后悔，结局是心酸的，但能感受女孩和男孩在一起的那些日子是非常幸福的。“我叫苏萍，萍水相逢的苏萍。” &emsp;&emsp;世上有太多阳光照不到的地儿，人心是最难琢磨的，你看北京熙熙攘攘的街头，每个人心里都揣着事儿，也许是好的，也许是坏的，但对外人永远都是最好的一面。 想到一首陈柏霖的歌 – “南城”","link":"/exclude/essay/Reading/r2.html"},{"title":"卑微如尘","text":"看到一本书，讲的是关于爱情的。看完第五章后，最后写到那个故事的女主角（许彤）写过的一篇文章，就想记下来。（2019.1.17 22:46 PM） &emsp;&emsp;因为某些特别的原因，对方的心根本不在你这儿，你于对方而言也不过是一个寂寞时候的聊伴而已，你的生气抱怨甚至是吃醋，都不是名正言顺的。 &emsp;&emsp;因为对方就没给过你任何身份，朋友？同事？同学？陌生人？这些通通都不是。 &emsp;&emsp;你是什么连你自己都不清楚，就连别人问起来，你都不知道该如何回答，因为这种关系本就尴尬。 &emsp;&emsp;你总不能和别人说，这是我的暗恋，这是我将来要嫁的人，傻不傻啊？ &emsp;&emsp;人是最复杂的动物，总是喜欢吃着碗里的瞧着锅里的，人一生中总会遇见几个渣人。你唯一能做的，就是别把自己变成那种人，能跟你暧昧的人，也会和别人暧昧。 &emsp;&emsp;对方既然不喜欢你，就不该接近你，对方故意施舍给你温柔，比用刀子插在你心上更让你难受，你或许一开始享受这样的过程，但最后只会剩下恶心。 &emsp;&emsp;一个人可以送你回家，牵着你的手过马路，带你去吃饭，离别的时候也会拥抱你，甚至和你上床，但就是绝口不提“我爱你”这三个字。有些事你总会明白，只是时间的早晚。 &emsp;&emsp;最后，这个人会对你说，你会遇见比他更好的人，但其实是他想拥有比你更好的人。 &emsp;&emsp;仔细想想那些你最后失望离开的人，是不是变成了你不主动联系，他就不会联系你的结局。 &emsp;&emsp;你为了这个人把所有的卑微都尝过一遍，在这不算太长的时间里，把你所有的耐心和自信都磨光了，对方把你当什么？ &emsp;&emsp;你心里早已清楚，不是所有感情都能称之为感情的。 &emsp;&emsp;你大概只有和这个人在一起的时候才会卑微吧，温顺得像一朵没有自己的雏菊。 &emsp;&emsp;很久以后，你在别人眼里变得高冷难以接近，你才明白，这辈子好像只对一个人低过头。 &emsp;&emsp;可有什么用呢？换不来你想要的感情，换不来你想要的结局，备胎不好当。 &emsp;&emsp;暧昧的对象更不是人当的，就算你曾经如此卑微过，也不必笑话自己，谁都一样，为了自己喜欢的人，甘愿不要脸。 &emsp;&emsp;当你终于肯放下这个人重新开始的时候，这个人在将来的某一天，也一定会想起你曾经的好，还是会回头来找你，但你就别再理了，如果对方说让你再等一段时间，也别信了。 &emsp;&emsp;那只是对方现在没空出时间来搭理你，甚至说人家骑驴找马，你连那匹马都不是，难听的话比比皆是。 &emsp;&emsp;也不是说非要让你难过得不行，只是希望你能明白，一辈子委屈一次就行了，别不长记性。 &emsp;&emsp;去找一个喜欢你各种样子的人，你不用穿得很漂亮去讨好对方，也不用说很多甜言蜜语的话。 &emsp;&emsp;你更不用频繁地更新状态让对方注意你，你甚至不用哭得死去活来，来让对方关心你。 &emsp;&emsp;一个真爱你的人，你不说话，也会爱你，就像我的牧沐。 &emsp;&emsp;你走不进一个人的心里，不是你不够优秀，也不是你不够努力，而是那个人的心对你设定了不可见，你再怎么努力也是徒劳无功的。 &emsp;&emsp;对方心里有墙，你就是撞得头破血流，人家也不会心疼的。 &emsp;&emsp;希望我能学会自私一点儿，只懂得如何对自己好，不再委曲求全于任何人，不爱你的就不爱。 &emsp;&emsp;没必要再去争抢，是你的人，就算丢了还会找到你，不是你的，绑在身边也徒劳无功。 &emsp;&emsp;所有的长篇大论不过是想说一个道理，有些人，不爱就是不爱。有些感情，不行就是不行。","link":"/exclude/essay/Reading/r3.html"},{"title":"我会记得你，然后爱别人（续）","text":"给爱情打一针镇定剂 ::: tip 关于幸福幸福其实就是你自己内心的愉悦，这种愉悦和自由不用外在任何的事情或者人来达到，哪怕你孤单一人，在图书馆里泡一杯咖啡，但你内心丰满，这就是幸福。::: &emsp;&emsp;这世上每天都有故事在发生，或温暖或悲伤，但在时间面前，一切都显得微不足道。那些留下来的故事，从岁月的尘埃里走过，看起来满是灰尘，却又无比美好。 世上是有真爱的，在对的时间遇见了对的人，他们之间相互包容，相互理解，因此最终走到了最后，白头偕老。 在爱情面前，不要做一个卑微的人，因为感情是对等的，不是一方拼命的付出，别人就一定会喜欢你，真正的爱情你甚至不需要多说一句话，对方就能明白，爱情不是一切，如果你喜欢的人根本不喜欢你，那就主动放弃吧，这不代表你不够好，只是走错了路，爱错了人。两个人在一起，光有爱情是不够的，得有一个人知冷知热，懂得让步，当然，最终还得有面包。爱情不过是锦上添花，重要的还是你自己，不要因为爱情而把自己弄丢了。亲情 &gt; 友情 &gt; 爱情，爱情不是等来的，美好的爱情是需要自己努力争取的，没有天上掉馅饼这种好事，对爱情的追求需要冲动和勇敢，世界上最荒谬的错觉就是我喜欢的人也会喜欢我。最后，希望有情人终成眷属，春有百花秋有月，夏有凉风冬有雪。 所谓的释然是什么？就是终于有一天你发现，你曾经那么喜欢的一个人，会被岁月打磨成你最讨厌的样子，你曾经以为得不到的感情，结局未必就一定是最好的。 世上最难受的事，莫过于爱上一个自己认定的却又注定跟你没什么关系的人。 一切不能挽回的事，都该让它彻底滚蛋。 希望你不缺钱花，自由，并四海为家。","link":"/exclude/essay/Reading/r4.html"},{"title":"SQL(2)","text":"查询数据基本查询要查询数据库表的数据，我们使用如下的SQL语句： 1SELECT * FROM &lt;表名&gt; 假设表名是students，要查询students表的所有行，我们用如下SQL语句： 1SELECT * FROM students; 使用SELECT * FROM students时，SELECT是关键字，表示将要执行一个查询，*表示“所有列”，FROM表示将要从哪个表查询，本例中是students表。 该SQL将查询出students表的所有数据。注意：查询结果也是一个二维表，它包含列名和每一行的数据。 SELECT语句其实并不要求一定要有FROM子句。我们来试试下面的SELECT语句： 1SELECT 100+200; 上述查询会直接计算出表达式的结果。虽然SELECT可以用作计算，但它并不是SQL的强项。但是，不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接。 条件查询使用SELECT * FROM &lt;表名&gt;可以查询到一张表的所有记录。但是，很多时候，我们并不希望获得所有记录，而是根据条件选择性地获取指定条件的记录，例如，查询分数在80分以上的学生记录。在一张表有数百万记录的情况下，获取所有记录不仅费时，还费内存和网络带宽。 SELECT语句可以通过WHERE条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成WHERE条件就是SELECT * FROM students WHERE score &gt;= 80。 其中，WHERE关键字后面的score &gt;= 80就是条件。score是列名，该列存储了学生的成绩，因此，score &gt;= 80就筛选出了指定条件的记录。 因此，条件查询的语法就是： 1SELECT * FROM &lt;表名&gt; WHERE &lt;条件表达式&gt; AND 条件表达式可以用&lt;条件1&gt; AND &lt;条件2&gt;表达满足条件1并且满足条件2。例如，符合条件“分数在80分或以上”，并且还符合条件“男生”，把这两个条件写出来： 条件1：根据score列的数据判断：score &gt;= 80；条件2：根据gender列的数据判断：gender = 'M'，注意gender列存储的是字符串，需要用单引号括起来。就可以写出WHERE条件：score &gt;= 80 AND gender = 'M'： 1SELECT * FROM students WHERE score &gt;= 80 AND gender = 'F'; OR 第二种条件是&lt;条件1&gt; OR &lt;条件2&gt;，表示满足条件1或者满足条件2。例如，把上述AND查询的两个条件改为OR，查询结果就是“分数在80分或以上”或者“男生”，满足任意之一的条件即选出该记录： 1SELECT * FROM students WHERE score &gt;= 80 OR gender = 'M'; 很显然OR条件要比AND条件宽松，返回的符合条件的记录也更多。 NOT 第三种条件是NOT &lt;条件&gt;，表示“不符合该条件”的记录。例如，写一个“不是2班的学生”这个条件，可以先写出“是2班的学生”：class_id = 2，再加上NOT：NOT class_id = 2： 1SELECT * FROM students WHERE class_id &lt;&gt; 2; 上述NOT条件NOT class_id = 2其实等价于class_id &lt;&gt; 2，因此，NOT查询不是很常用。 多个条件组合 要组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算。例如，编写一个复杂的条件：分数在80以下或者90以上，并且是男生： 1SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender = 'M'; 如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR。加上括号可以改变优先级。 常用的条件表达式 条件 表达式举例1 表达式举例2 说明 使用=判断相等 score = 80 name = ‘abc’ 字符串需要用单引号括起来 使用&gt;判断大于 score &gt; 80 name &gt; ‘abc’ 字符串比较根据ASCII码，中文字符比较根据数据库设置 使用&gt;=判断大于或相等 score &gt;= 80 name &gt;= ‘abc’ 使用&lt;判断小于 score &lt; 80 name &lt;= ‘abc’ 使用&lt;=判断小于或相等 score &lt;= 80 name &lt;= ‘abc’ 使用&lt;&gt;判断不相等 score &lt;&gt; 80 name &lt;&gt; ‘abc’ 使用LIKE判断相似 name LIKE ‘ab%’ name LIKE ‘%bc%’ %表示任意字符，例如’ab%’将匹配’ab’，’abc’，’abcd’ 投影查询使用SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。 如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用SELECT 列1, 列2, 列3 FROM ...，让结果集仅包含指定列。这种操作称为投影查询。 例如，从students表中返回id、score和name这三列： 12-- 使用投影查询SELECT id, score, name FROM students; 这样返回的结果集就只包含了我们指定的列，并且，结果集的列的顺序和原表可以不一样。 使用SELECT 列1, 列2, 列3 FROM ...时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...。 例如，以下SELECT语句将列名score重命名为points，而id和name列名保持不变： 12-- 使用投影查询，并将列名重命名：SELECT name, id, score points FROM students; 投影查询同样可以接WHERE条件，实现复杂的查询： 12-- 使用投影查询+WHERE条件：SELECT id, score points, name FROM students WHERE gender = 'M'; 排序我们使用SELECT查询时，查询结果集通常是按照id排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上ORDER BY子句。例如按照成绩从低到高进行排序： 12-- 按score从低到高SELECT id, name, gender, score FROM students ORDER BY score; 如果要反过来，按照成绩从高到底排序，我们可以加上DESC表示“倒序”： 12-- 按score从高到低SELECT id, name, gender, score FROM students ORDER BY score DESC; 如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用ORDER BY score DESC, gender表示先按score列倒序，如果有相同分数的，再按gender列排序： 12-- 按score, gender排序:SELECT id, name, gender, score FROM students ORDER BY score DESC, gender; 默认的排序规则是ASC：“升序”，即从小到大。ASC可以省略，即ORDER BY score ASC和ORDER BY score效果一样。 如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面。例如，查询一班的学生成绩，并按照倒序排序： 12345-- 带WHERE条件的ORDER BY:SELECT id, name, gender, scoreFROM studentsWHERE class_id = 1ORDER BY score DESC; 这样，结果集仅包含符合WHERE条件的记录，并按照ORDER BY的设定排序。 分页查询使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。 要实现分页功能，实际上就是从结果集中显示第1100条记录作为第1页，显示第101200条记录作为第2页，以此类推。 因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过LIMIT &lt;M&gt; OFFSET &lt;N&gt;子句实现。我们先把所有学生按照成绩从高到低进行排序： 12-- 按score从高到低SELECT id, name, gender, score FROM students ORDER BY score DESC; 现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用LIMIT 3 OFFSET 0： 12345-- 查询第1页SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 0; 上述查询LIMIT 3 OFFSET 0表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。 如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：LIMIT 3 OFFSET 3;类似的，查询第3页的时候，OFFSET应该设定为6:LIMIT 3 OFFSET 6;查询第4页的时候，OFFSET应该设定为9:LIMIT 3 OFFSET 9;如果最后一页只有1条记录，因此最终结果集按实际数量1显示。LIMIT 3表示的意思是“最多3条记录”。 可见，分页查询的关键在于，首先要确定每页需要显示的结果数量pageSize（这里是3），然后根据当前页的索引pageIndex（从1开始），确定LIMIT和OFFSET应该设定的值： LIMIT总是设定为pageSize；OFFSET计算公式为pageSize * (pageIndex - 1)。这样就能正确查询出第N页的记录集。 如果原本记录集一共就10条记录，但我们把OFFSET设置为20，会得到什么结果呢？ 1234567-- OFFSET设定为20SELECT id, name, gender, scoreFROM studentsORDER BY score DESCLIMIT 3 OFFSET 20;-- 结果Empty result set OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。 注意 OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。 在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30 15。 可以使用count(*)查询数据条数: 1SELECT count(*id*) FROM students; COUNT()函数返回匹配指定条件的行数: COUNT(column_name) 函数返回指定列的值的数目（NULL 不计入）：1SELECT COUNT(column_name) FROM table_name COUNT(*) 函数返回表中的记录数：1SELECT COUNT(*) FROM table_name COUNT(DISTINCT column_name) 函数返回指定列的不同值的数目：123SELECT COUNT(DISTINCT column_name) FROM table_name-- 注：COUNT(DISTINCT) 适用于 ORACLE 和 Microsoft SQL Server，但是无法用于 Microsoft Access。 聚合查询如果我们要统计一张表的数据量，例如统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。 仍然以查询students表一共有多少条记录为例，我们可以使用SQL内置的COUNT()函数查询： 12-- 使用聚合查询:SELECT COUNT(*) FROM students; COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)。 通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果： 12-- 使用聚合查询并设置结果集的列名为num:SELECT COUNT(*) num FROM students; COUNT(*)和COUNT(id)实际上是一样的效果。另外注意，聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等： 12-- 使用聚合查询并设置WHERE条件:SELECT COUNT(*) boys FROM students WHERE gender = 'M'; 除了COUNT()函数外，SQL还提供了如下聚合函数：| 函数 | 说明 || :—-: | :—-: || SUM | 计算某一列的合计值，该列必须为数值类型 || AVG | 计算某一列的平均值，该列必须为数值类型 || MAX | 计算某一列的最大值 || MIN | 计算某一列的最小值 |注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。 要统计男生的平均成绩，我们用下面的聚合查询： 12-- 使用聚合查询计算男生平均成绩:SELECT AVG(score) average FROM students WHERE gender = 'M'; 要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而MAX()、MIN()、MAX()和MIN()会返回NULL; 分组 如果我们要统计一班的学生数量，我们知道，可以用SELECT COUNT(*) num FROM students WHERE class_id = 1;。如果要继续统计二班、三班的学生数量，难道必须不断修改WHERE条件来执行SELECT语句吗？ 对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询： 12-- 按class_id分组:SELECT COUNT(*) num FROM students GROUP BY class_id; 执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。 但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中： 12-- 按class_id分组:SELECT class_id, COUNT(*) num FROM students GROUP BY class_id; 这下结果集就可以一目了然地看出各个班级的学生人数。我们再试试把name放入结果集： 12-- 按class_id分组:SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id; 不出意外，执行这条查询我们会得到一个语法错误，因为在任意一个分组中，只有class_id都相同，name是不同的，SQL引擎不能把多个name的值放入一行记录中。因此，聚合查询的列中，只能放入分组的列。 也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数： 12-- 按class_id, gender分组:SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender; 上述查询结果集一共有6条记录，分别对应各班级的男生和女生人数。 练习请使用一条SELECT查询查出每个班级的平均分： 12-- 查出每个班级的平均分，结果集应当有3条记录:SELECT class_id, AVG(score) FROM students GROUP BY class_id ; 请使用一条SELECT查询查出每个班级男生和女生的平均分： 12-- 查出每个班级的平均分，结果集应当有6条记录:SELECT class_id, gender, AVG(score) FROM students GROUP BY class_id, gender; 多表查询SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：SELECT * FROM &lt;表1&gt; &lt;表2&gt;。 例如，同时从students表和classes表的“乘积”，即查询数据，可以这么写： 1SELECT * FROM students, classes; 这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。 这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。 你可能还注意到了，上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理 要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名： 123456789-- set alias:SELECT students.id sid, students.name, students.gender, students.score, classes.id cid, classes.name cnameFROM students, classes; 注意，多表查询时，要使用表名.列名这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用表名.列名这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点： 123456789-- set table alias:SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cnameFROM students s, classes c; 注意到FROM子句给表设置别名的语法是FROM &lt;表名1&gt; &lt;别名1&gt;, &lt;表名2&gt; &lt;别名2&gt;。这样我们用别名s和c分别表示students表和classes表。 多表查询也是可以添加WHERE条件的： 12345678910-- set where clause:SELECT s.id sid, s.name, s.gender, s.score, c.id cid, c.name cnameFROM students s, classes cWHERE s.gender = 'M' AND c.id = 1; 这个查询的结果集每行记录都满足条件s.gender = ‘M’和c.id = 1。添加WHERE条件后结果集的数量大大减少了。 连接查询连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。 例如，我们想要选出students表的所有学生信息，可以用一条简单的SELECT语句完成： 1SELECT s.id, s.name, s.class_id, s.gender, s.score FROM students s; 但是，假设我们希望结果集同时包含所在班级的名称，上面的结果集只有class_id列，缺少对应班级的name列。 现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。 这时，连接查询就派上了用场。我们先使用最常用的一种内连接——INNER JOIN来实现： 12345-- 选出所有学生，同时返回班级名称SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.scoreFROM students sINNER JOIN classes cON s.class_id = c.id; 注意INNER JOIN查询的写法是： 先确定主表，仍然使用FROM &lt;表1&gt;的语法； 再确定需要连接的表，使用INNER JOIN &lt;表2&gt;的语法； 然后确定连接条件，使用ON &lt;条件...&gt;，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接； 可选：加上WHERE子句、ORDER BY等子句。使用别名不是必须的，但可以更好地简化查询语句。 外连接（OUTER JOIN） 执行上述RIGHT OUTER JOIN可以看到，和INNER JOIN相比，RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。 这也容易理解，因为根据ON条件s.class_id = c.id，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。 有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是： INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。 RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段。 LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一列，并添加class_id=5，由于classes表并不存在id=5的列，所以，LEFT OUTER JOIN的结果会增加一列，对应的class_name是NULL。 FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL： 对于这么多种JOIN查询，到底什么使用应该用哪种呢？其实我们用图来表示结果集就一目了然了。 假设查询语句是： 1SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2; 我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录： LEFT OUTER JOIN是选出左表存在的记录： RIGHT OUTER JOIN是选出右表存在的记录： FULL OUTER JOIN则是选出左右表都存在的记录：","link":"/exclude/Database/sql_1.html"},{"title":"ARKit + SceneKit","text":"iOS ARKit + SceneKit硬件要求 处理器 A9以上 iOS系统 iOS11.0+ Xcode 9.0+ ARKitARKit可以支持2D、3D的场景，2D场景需要加载ARSKView，3D场景需要加载ARSCNView。两者除了虚拟场景制作不同之外，其他都是相同的。2D场景使用SpriteKit制作，3D使用SceneKit制作，我们以3D场景为例做介绍。 开发3D ARKit需要使用ARSCNView，ARSCNView已经将开发AR的所有API封装了，可以方便的使用。在ARSCNView中，session是管理类，捕获真实世界、世界追踪、渲染都由session完成，session在初始化时必须为其提供configuration才行。scene是负责做虚拟化的类，每个虚拟物体都是一个节点（SCNNode），所有节点都有一个公共父节点（rootNode），每个节点也可以添加自己的子节点。可以为每个节点添加动画效果，可以使用core animation添加，也可以使用其自带的runAction添加。可以在ARSCNView中添加Anchor，可以通过session手动添加，也可以打开平面检测自动添加。 AR显示（Display）SCNScene要在视图中显示的场景。 场景中的虚拟物体是由一个一个的节点（SCNNode）组成的。物体可以使用专业的3D建模软件制作，制作好之后在工程中导入.scn文件即可。 每个scene中会有一个root节点，该节点就在原坐标系的原点，不能做任何的修改。scene中所有节点的公共父节点都是root节点，节点可以有自己的子节点，节点的组成是树形结构的。每个节点都有自己的坐标系，其坐标系原点的位置就是在其父节点坐标系的位置。 在生成节点时，最好指设置name属性，以方便交互。系统为我们提供了很多几何体来生成节点，比如平面、长方体、球体等。我们还可以使用两种方法给节点添加动画，core animation或者runAction，这里不详细介绍了。 ARSCNView (3D)SCNViewSCNView用来将SCNScene的内容展示到屏幕上，其基本用法如下： 创建一个SCNView实例 将创建的scene实例设置SCNView的scene属性 将SCNView实例添加到UIKit的UIView或者UIWindow上 ARSCNViewARSCNView继承自SCNView，将虚拟3D内容与现实世界的设备相机视图相融合。运行视图提供的ARSession对象时： 视图会自动将设备摄像头的实时视频输入渲染为场景背景 视图的SceneKit场景的世界坐标系直接响应由会话配置建立的AR世界坐标系 视图会自动移动其SceneKit相机以匹配设备的实际移动 ARSCNViewDelegate ARSCNView中的三种代理分别为： ARSCNViewDelegate SCNSceneRendererDelegate ARSessionObserver ARSCNViewDelegate是关于在平面上添加节点的。具体如下： 12345678// 在Anchor上添加节点- (nullable SCNNode )renderer:(id )renderer nodeForAnchor:(ARAnchor )anchor; // 当一个新节点被映射到给定的锚点时调用, node 为映射到锚的节点- (void)renderer:(id )renderer didAddNode:(SCNNode )node forAnchor:(ARAnchor )anchor; // 更新节点- (void)renderer:(id )renderer willUpdateNode:(SCNNode )node forAnchor:(ARAnchor )anchor;// 移除节点- (void)renderer:(id )renderer didRemoveNode:(SCNNode )node forAnchor:(ARAnchor )anchor; SCNSceneRendererDelegate是渲染代理，ARSessionObserver是session相关的代理，开发时可以查看官方文档。 ARSKView (2D)捕获真实世界摄像头捕获真实的世界的图像作为AR世界的背景显示，使用的过程中，涉及到三个核心类：ARSession、ARFrame和ARCamera。 ARSession一个共享对象，用于管理AR体验所需的设备摄像头和运动处理。包括： 从设备的运动传感器读取数据 控制设备的内置摄像头，利用 AVCaptureSession 捕获实时的图像 对捕获到的图像进行分析，并对外输出 ARFrame 实例 综合运动数据和图像分析结果，建立起真实世界和虚拟世界的对应关系 使用ARKit构建的每个AR应用都需要一个ARSession对象。如果使用ARSCNView或ARSKView对象构建AR的可视部分，则视图对象本身包含一个ARSession实例。如果为AR内容构建自己的渲染器，则需要自己实例化和维护ARSession对象。 运行会话需要配置: ARConfiguration（使用时使用它的子类，如ARWorldTrackingConfiguration）。ARConfiguration用于确定ARKit如何跟踪设备相对于现实世界的位置和运动，从而影响创建的AR体验类型。 配置并运行一个会话 1234567891011121314// 使用指定的配置和选项启动ARSession- runWithConfiguration:options:// 使用指定的配置启动ARSession- runWithConfiguration:// 更改其配置时影响如何转换ARSession的当前状态的选项ARSessionRunOptions// 定义会话的运动和场景跟踪行为的对象configuration// 暂停会话- pause 世界追踪（World Tracking）世界追踪（World Tracking）将虚拟世界和真实世界联系起来，这里追踪的“世界”是“真实世界”。ARSession是整个世界追踪的核心类，连接虚拟世界和真实世界需要运行ARSession实例，运行方式和前面“捕获真实世界”中的方式一样。追踪原理大致如下： ARSession 使用 AVCaptureSession 捕获实时的图像 ARSession 使用 CMMotionManager 追踪设备的移动数据 图像处理结束完成之后 ARSession 输出 ARFrames 相关类如下： 和configuration相关的ARWorldTrackingConfiguration、AROrientationTrackingConfiguration 等 和追踪结果相关的ARPlaneAnchor 类 获取世界追踪状态信息的 ARSessionDelegate ARWorldTrackingConfigurationARWorldTrackingConfiguration可以将虚拟世界和真实世界联系起来，这样当虚拟世界和真实世界同时渲染在屏幕上的时候，用户会产生虚拟内容是真实世界的一部分的错觉。运行 session 的时候，若将configuration参数设为 ARWorldTrackingConfiguration，ARKit将会： 调用系统后置摄像头 追踪设备方向 追踪设备位置 检测真实世界的平面 维护真实世界和虚拟世界的对应关系，需要获取设备的移动信息。ARWorldTrackingConfiguration类从6个自由度（degrees of freedom）来追踪设备的运动：具体来说，三个旋转轴（滚动，俯仰和偏航）以及三个平移轴（在X，Y和Z中的移动）。这种追踪可以给用户带来沉浸式的体验：虚拟世界的物体可以看起来与现实世界保持相同的位置，即使用户将设备倾斜到物体的上方或下方，或者移动设备以查看物体的侧面和背面。 AROrientationTrackingConfiguration和 ARWorldTrackingConfiguration 类似，设置 AROrientationTrackingConfiguration 属性之后： 调用系统后置摄像头 只追踪设备方向 不追踪设备位置 不检测真实世界的平面 ARPlaneAnchoranchor 翻译为锚点，在世界追踪的AR session 中，一个 ARPlaneAnchor 对象表示在真实世界中，一个平面的位置和方向信息。ARPlaneAnchor 是 ARAnchor 的子类。 ARAnchor锚点表示真实世界的位置和方向，为AR场景中放置虚拟物体提供位置信息。在开发的过程中，需要掌握对anchor的如下操作： 手动向ARSession 中添加、移除锚点：如果需要追踪真实世界中的某个点，创建一个锚点对象，然后用add(anchor:)方法将其添加到session中 获取ARSession 中的所有锚点：session.currentFrame.anchors ARKit自动添加锚点：如果开启了平面检测，系统为检测到的平面自动添加锚点 ARSessionDelegate：实现该delegate，可以接收到锚点添加、更新和移除的通知 其实ARAnchor的定义比较简单，包含属性： identifier ：唯一表示锚点 transform：用 matrix_float4x4，一个四维的数据来表示锚点位置信息 … 12345678910111213141516171819/** Object representing a physical location and orientation in 3D space. */API_AVAILABLE(ios(11.0))@interface ARAnchor : NSObject &lt;ARAnchorCopying, NSSecureCoding&gt;/** Unique identifier of the anchor. */@property (nonatomic, readonly) NSUUID *identifier;/** The transformation matrix that defines the anchor’s rotation, translation and scale in world coordinates. */@property (nonatomic, readonly) simd_float4x4 transform;...@end ARPlaneAnchor注意：iOS 11.3之前只支持水平面检测，11.3开始支持垂直面检测！ 当运行启用了planeDetection选项的世界追踪AR session时，每检测到一个平面，ARKit会自动将表示该平面的ARPlaneAnchor对象添加到一个数组中去。 每个ARPlaneAnchor对象提供关于平面的位置和形状的信息。 ARPlaneAnchor 在 ARAnchor 基础上添加了和“平面”相关的属性alignment、center、 extent 和 geometry。 extent 和 center 属性比较好理解，就是平面的中心点和大小； alignment 描述这个平面相对重力的方向，可以取两个值 horizontal 和 vertical（iOS 11.3+）； geometry 也是 iOS 11.3新增的属性，可以辅助我们做可视化 AR图像识别使用系统自带API 在 Assets.xcassets 文件目录下新建一个 AR Resource Group 类型的目录并导入要识别的图片(导入后需要设置图片的size) 定义ARReferenceImage 对象并赋值给 ARWorldTrackingConfiguration的detectionImages属性 遵守ARSCNViewDelegate协议并在- (void)renderer:(id&lt;SCNSceneRenderer&gt;)renderer didAddNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor;方法中获取参考图片对象，获取后进行图片判断。 工程中用到的模型资源地址：地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211#import &quot;ARSCNViewController.h&quot;#import &lt;ARKit/ARKit.h&gt;#import &lt;SceneKit/SceneKit.h&gt;@interface ARSCNViewController () &lt;ARSessionDelegate, ARSCNViewDelegate&gt;@property (nonatomic, strong) ARSCNView *arScnView;@property (nonatomic, strong) ARSession *arSession;@property (nonatomic, strong) ARWorldTrackingConfiguration *arSessionConfiguration;@end@implementation ARSCNViewController- (void)viewDidLoad { [super viewDidLoad]; [self.view addSubview:self.arScnView]; { UIButton *btn = [[UIButton alloc] initWithFrame:CGRectMake(20, 70, 60, 40)]; btn.layer.backgroundColor = UIColor.orangeColor.CGColor; [btn setTitle:@&quot;back&quot; forState:UIControlStateNormal]; [btn addTarget:self action:@selector(btnClick) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:btn]; [self.view bringSubviewToFront:btn]; } if (ARConfiguration.isSupported) {// 判断是否支持AR }}- (void)btnClick { [self dismissViewControllerAnimated:true completion:nil];}- (void)viewWillAppear:(BOOL)animated { [super viewWillAppear:animated]; [self.arSession runWithConfiguration:self.arSessionConfiguration options:ARSessionRunOptionResetTracking |ARSessionRunOptionRemoveExistingAnchors];}- (void)viewWillDisappear:(BOOL)animated { [super viewWillDisappear:animated]; [self.arSession pause];}- (void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated];}#pragma mark -- (void)renderer:(id&lt;SCNSceneRenderer&gt;)renderer didAddNode:(SCNNode *)node forAnchor:(ARAnchor *)anchor { ARImageAnchor * imageAnchor = (ARImageAnchor *)anchor; //获取参考图片对象 ARReferenceImage * referenceImage = imageAnchor.referenceImage; if ([referenceImage.name isEqual: @&quot;ar&quot;]) { NSLog(@&quot;referenceImage: ar&quot;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // Scene is modified when rendering callback NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;art.scnassets/skinning&quot; withExtension:@&quot;dae&quot;]; if (!url) { NSLog(@&quot;url 为空&quot;); return; } SCNReferenceNode *rNode = [[SCNReferenceNode alloc] initWithURL:url];// rNode.scale = SCNVector3Make(0.0005, 0.0005, 0.0005);// rNode.eulerAngles = SCNVector3Make(-M_PI/2.1, 0, 0); [rNode load]; rNode.scale = SCNVector3Make(0.0003, 0.0003, 0.0003); rNode.position = SCNVector3Make(0, -1, -1); dispatch_async(dispatch_get_main_queue(), ^{// [node addChildNode:rNode]; [self.arScnView.scene.rootNode addChildNode:rNode]; }); }); } if ([referenceImage.name isEqual: @&quot;ar2&quot;]) { NSLog(@&quot;referenceImage: ar2&quot;); SCNNode *tempNode = [SCNNode new]; CGFloat w = referenceImage.physicalSize.width; CGFloat h = referenceImage.physicalSize.height; SCNBox *box = [SCNBox boxWithWidth:w*0.5 height:w*0.5 length:h*0.5 chamferRadius:0]; box.firstMaterial.diffuse.contents = UIColor.orangeColor; tempNode.geometry = box; tempNode.eulerAngles = SCNVector3Make(-M_PI/2.0, -M_PI/2.0, 0); tempNode.opacity = 1;//透明度 //摇摆动画 SCNAction *action = [SCNAction rotateToX:-M_PI y:0 z:M_PI duration:2]; SCNAction *action1 = [SCNAction rotateToX:-M_PI y:0 z:-M_PI duration:2]; SCNAction *sequence =[SCNAction sequence:@[action, action1]]; [tempNode runAction:[SCNAction repeatAction:sequence count:MAXFLOAT]]; [node addChildNode:tempNode]; } if ([referenceImage.name isEqual: @&quot;ar3&quot;]) { NSLog(@&quot;referenceImage: ar3&quot;); dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ // Scene is modified when rendering callback// SCNScene *scene = [SCNScene sceneNamed: @&quot;art.scnassets/ship.scn&quot;];// SCNNode *shipNode = scene.rootNode.childNodes[0]; //此方法加载模型位置不对 NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;art.scnassets/ship&quot; withExtension:@&quot;scn&quot;]; if (!url) { NSLog(@&quot;url 为空&quot;); return; } SCNReferenceNode *shipNode = [[SCNReferenceNode alloc] initWithURL:url]; shipNode.eulerAngles = SCNVector3Make(-M_PI/2.0, 0, 0); [shipNode load]; // shipNode.position = SCNVector3Make(0, -1, -1); dispatch_async(dispatch_get_main_queue(), ^{ //左右摇摆动画 SCNAction *action11 = [SCNAction rotateToX:-M_PI/2.0 y:0.5 z:0 duration:0.5]; SCNAction *action12 = [SCNAction rotateToX:-M_PI/2.0 y:-0.5 z:0 duration:0.5]; SCNAction *sequence1 =[SCNAction sequence:@[action11,action12]]; [shipNode runAction:[SCNAction repeatAction:sequence1 count:MAXFLOAT]]; [node addChildNode:shipNode];// [self.arScnView.scene.rootNode addChildNode:shipNode]; }); }); }}#pragma mark - &lt;ARSessionDelegate&gt;/// 会话位置更新（监听相机的移动），此代理方法会调用非常频繁，只要相机移动就会调用，如果相机移动过快，会有一定的误差，具体的需要强大的算法去优化- (void)session:(ARSession *)session didUpdateFrame:(ARFrame *)frame {// NSLog(@&quot;相机移动&quot;);}- (void)session:(ARSession *)session didAddAnchors:(NSArray&lt;ARAnchor *&gt; *)anchors {// NSLog(@&quot;添加锚点&quot;);}- (void)session:(ARSession *)session didUpdateAnchors:(NSArray&lt;ARAnchor *&gt; *)anchors {// NSLog(@&quot;刷新锚点&quot;);}- (void)session:(ARSession *)session didRemoveAnchors:(NSArray&lt;ARAnchor *&gt; *)anchors { NSLog(@&quot;移除锚点&quot;);}- (void)session:(ARSession *)session didFailWithError:(NSError *)error { NSLog(@&quot;message error: %@&quot;, error.description);}#pragma mark -- (ARSCNView *)arScnView { if (!_arScnView) { // 创建AR视图 _arScnView = [[ARSCNView alloc] initWithFrame:self.view.bounds]; _arScnView.delegate = self; // 设置视图会话 _arScnView.session = self.arSession; // Show statistics such as fps and timing information _arScnView.showsStatistics = YES; } return _arScnView;}// AR会话，负责管理相机追踪配置及3D相机坐标- (ARSession *)arSession { if (!_arSession) { _arSession = [[ARSession alloc] init]; _arSession.delegate = self; } return _arSession;}// 会话追踪配置：负责追踪相机的运动- (ARWorldTrackingConfiguration *)arSessionConfiguration { if (!_arSessionConfiguration) { // 创建世界追踪会话配置（使用ARWorldTrackingSessionConfiguration效果更加好），需要A9芯片支持 _arSessionConfiguration = [[ARWorldTrackingConfiguration alloc] init]; // 设置追踪方向（追踪平面）// _arSessionConfiguration.planeDetection = ARPlaneDetectionHorizontal; // 自适应灯光（相机从暗到强光快速过渡效果会平缓一些） _arSessionConfiguration.lightEstimationEnabled = true; // 图像检测 _arSessionConfiguration.detectionImages = [ARReferenceImage referenceImagesInGroupNamed:@&quot;AR Resources&quot; bundle:nil]; } return _arSessionConfiguration;}@end","link":"/exclude/iOS/ARKitAndSceneKit.html"},{"title":"人性的弱点","text":"不乱于心，不困于情，不畏将来，不念过往。 人性的弱点O(∩_∩)O！保持乐观的心态，用温柔的心对待这个世界；保持本心，不忘初心，做最好的自己；待人真诚，学会赞美和欣赏他人；多为别人考虑，并站在对方的角度考虑问题；了解对方的兴趣，讨论对方感兴趣的话题；勇于承担责任，不逃避自己的过错；做自己喜欢的事情，用快乐的心态面对每一天； 1. 与人相处 如欲采蜜，勿蹴蜂房 真诚的赞赏他人 欲钓鱼，先设美味的饵 避免批评、责骂和抱怨，保持他人的自尊感，批评和责骂会打击他人的自尊心，严重的时候可能成为危险的导火索（如果非要的话注意批评和责备的方式）； 每个人身上都会有他们的优点，尽量尝试了解别人，看到别人身上的缺点，真诚的赞赏他人； 学会理解和宽容，当然，这需要良好的品德和自我克制； 永远从别人的立场去思考，并从他的角度看问题，从而了解别人心里想些什么的人，就永远不用担心未来。 希望这个世界可以变得温暖，那就从欣赏和赞美别人开始吧 ~ ~ “赞赏是真诚的，恭维是虚伪的；赞赏是出自内心的，恭维只不过是口头上的；赞赏是没有丝毫自私目的的，恭维是出自个人私利的；赞赏是将会得到天下人钦佩的，恭维是只会被天下人唾弃的。” 关于恭维的定义，我曾读过这样一句话：“对别人的恭维，不过是婉转地表达对自己的赞美。” 也许你打算劝某个人去做某件事情。在你开口之前，不妨先问问自己：“我怎样才能使他心甘情愿地‘要’做这件事呢？” 2. 平安快乐 保持自我 养成良好的工作习惯 不要让疲倦征服自己 让自己的工作变得有意义 用快乐的心态面对今天 没人愿意踢一只死狗 不要报复你的敌人 不要要求别人感激你的恩德 牢记你所得的恩惠 在人生中反败为胜 每天都要带给别人快乐 懂得欣赏别人对自己的批评 学会自我批评 做最好的自己，保持精神和心理的健康，培养内心的安宁与快乐，用快乐的心态面对每一天。 大部分的疲劳来源于精神因素，因此，避免生活和工作中的忧虑、紧张和不快，远离压力，保持良好的精神状态，学会放松自己。 对自己的工作充满兴趣才不至于让自己疲惫不堪，热爱自己的工作，不要抱怨。 养成4种良好的工作习惯： 将桌上的纸张收拾好，只留下待解决的问题。 根据事情的重要程度安排做事的先后顺序。 当遇到必须当场决定的问题时，当场解决，不要犹豫。 学会如何组织、分级负责和监督。 不为小事而烦恼。 既然对人施恩就不要希望得到回报，那是不可强求的事情，也不要因为别人的忘恩负义而忧伤。 记住：要教育出感恩图报的孩子，就一定要自己先懂得感恩，然后，培养他们这样去做。 珍爱自己所拥有的。 不妨问问自己：“我到底在烦恼些什么呢？”你多半会发现，你所担心的事既不重要，也没有意义。 用心看世界，并体会其价值。 最美好的事往往也是最困难的。 学会反败为胜： “人生最重要的不只是运用自己所拥有的，因为任何人都会这样做，真正重大的课题是如何从你的损失中获益，这需要真正的智慧，也只有这样才显示出你的雄才大略。” 善待别人就是善待自己。 为什么做一件好事，能给人带来这么大的影响呢？因为当我们试着使别人高兴的时候，就不再会只想到自己。 帮助别人，这会给你带来更多的满足、更大的快乐以及更多的成就感。古代波斯拜火教的始祖佐罗亚斯特说：“为别人做好事并不是一种责任，而是一种快乐，因为这能增强你自己的健康和快乐。”亚里士多德称这种态度为“有益于人的自私”。富兰克林的说法则更简单：“当你善待别人的时候，就是善待你自己。” 接受别人的批评：撑起一把伞，让批评之雨顺着伞滑落；学会自我批评，有时候别人的看法比我们自己的观点更接近事实 “能做自己喜欢做的事情的人，是最幸运的人。” “善用你的天赋，归根究底，所有的艺术都是一种自我的体现。你只能唱你自己的歌、画你自己的画。你的经验、环境已经遗传并造就了你。不管好坏，你只需好好地经营自己的小花园；不论好坏，你只要在生命的管弦乐中演奏好属于自己的一件乐器。” “紧张是一种习惯，放松也是一种习惯。坏习惯可以改正，好习惯可以慢慢养成。那么，怎样才能放松自己呢？是从大脑开始，还是从神经开始？这些都不是，而是应该从肌肉开始放松。我们举例来说得具体一点：假定由眼睛开始，先把这一段文字读完，然后向后靠，闭上眼睛静静地对你的眼睛说：‘放松，放松，不皱眉头，不皱眉头，放松，放松……’你慢慢地重复约一分钟……” “其实，你完全可以随时随地放松自己，但千万不要费力要求自己放松下来。放松就是释放所有的紧张和努力。要想轻松自在，先得由放松自己的两眼和脸部开始，口里不断重复：‘放松……放松……松弛下来……’你可以感到一种活力从脸上肌肉中逸出，进入身体内部。这时你会觉得自己远离压力，像婴孩般自由自在。” “如果你是一个脑力劳动者，使你感觉疲劳的原因很少是因为你的工作超量，相反是由于你的工作量不足。” “他人之所以对你作出令人不愉快的反应，可能是因为你所说的话以及你说这些话的方式或态度不当。” “要培养内心的安宁与快乐，请记住：永远不要对敌人心存报复，否则，对自己的伤害将大过对别人的。 一些人的脸孔因为仇恨愤懑而布满了皱纹或变形。再好的整容手术都挽救不了，更远不及因宽恕、温柔、爱意所形成的容颜。 即使我们没有办法爱我们的敌人，但起码应该多爱自己一点。我们不应该让敌人控制我们的心情、健康以及容貌。” “其实，当我们施恩时，如果我们偶然得到了别人的感激，那是一种意外之喜；如果我们得不到这种感激，也不必为此而难过。” “我们的生活中大概有90%的事，都进行得很顺利，而只有10%出现问题。如果我们想要快乐，只需要集中注意力在那90%的好事上，不去看那10%便可以了。如果我们想要烦恼、抱怨、得胃溃疡，那只要集中注意力在10%的不满意之处，而忽略掉那90%也就可以了。” 根·史密斯有一句智慧之言：“人生有两项主要目标，第一，拥有你所向往的；第二，享受它们。只有最具智慧的人才能做到第二点。” 让我们一起谨记威廉·詹姆斯的名言：“只要将一个人内心的态度由恐惧转为奋斗，便能够克服任何障碍。” 让我们为自己的快乐而奋斗！ 活在今天我们应该懂得： 第一，今天我要让自己很开心。因为林肯说过：“多半的人都可以决定自己拥有更多的快乐。”快乐源于内心，并非外来之物。 第二，今天我要调适自己，而不是调整世界来配合我。我要让自己配合自己的家庭、事业与机运。 第三，今天我要照顾自己的身体。我要运动，关心它、滋养它、不滥用它、不忽略它，让它变成我心灵的殿堂。 第四，今天我要强化心灵。我要学习，不让心灵闲置，阅读需要聚精会神才能读懂的读物。 第五，今天我要从三方面操演我的心灵：我要默默地为一个人做件好事；至少做两件我不想做的事；照威廉·詹姆斯所说的，为了让心灵得到演练，不致怠惰。 第六，今天我要让自己怡人。使自己看来愉悦，穿着合宜，轻声慢语，举止恰当，多予赞赏，少作批评，不找任何事的毛病，也不挑任何人的缺点。 第七，今天要全心全意只活这一天，不去想自己的整个人生。一天工作12小时固然很好，如果想到一辈子都要如此，可能会先吓坏我自己。 第八，今天我要制订计划。计划每小时要做的事。可能不能完全遵行，但还是要计划，为的是避免仓促及犹豫不决。 第九，今天我要给自己保留半小时的轻松时间。用这半小时祈祷，想想自己的人生远景。 第十，今天我将无所畏惧，我不怕更快乐、更享受人生的美好；也不怕失去爱人，相信我爱的人亦爱我。 3. 让人喜欢你 发自内心的关怀他人 别忘记带上你的微笑 牢记他人的姓名 学会倾听 谈论他人感兴趣的话题 让他人感到自身的重要性 要交朋友，就要用热情和活力面对别人，就应该为别人去做那些需要花时间、精力、诚心和思考的事。 行为胜于言论，对人微笑就是向他人表明：“我喜欢你，你使我快乐，我喜欢见你。”，并且这种行为必须是发自内心的，而不是为了微笑而微笑。 你要别人怎么对待你，就得先怎样对待别人。 如果让别人喜欢你：真诚的关怀他人；带上你的微笑；牢记别人的姓名；做一个好的倾听者，鼓励他们谈论他们自己；了解对方的兴趣，谈论对方喜欢的话题；真诚的赞赏他人，让他人感到自己很重要。 “在走进别人的办公室以前，一定要停留片刻，思索应感谢他人的许多事，引出一个真诚的微笑来，然后面带微笑进入室内。” “不诚意的笑是骗不了人的。那种笑是机械的，人们厌恶它。我们现在是在讲一种真正的、热情的、发自内心的，那种在人际交往中极具价值的微笑。” “如果你希望别人看到你的时候很愉快，那你一定要记住：当你看见别人的时候，一定要心情愉悦。” “喜欢挑剔的人，甚至是最激烈的批评者，也常常会在一个具有忍耐心和同情心的倾听者面前软化。当怒火万丈的寻衅者像一条毒蛇张嘴咬人时，倾听者应当保持缄默，认真地倾听。” “人类本质中最殷切的需求是：渴望得到他人的肯定。现实生活中有些人之所以会出现交际障碍，是因为他们不懂得或忘记了一个重要的原则：让他人感到自己重要。” 4. 赢得他人的赞同 成功不需要争辩不休 千万不要指责他人的错误 勇于承认自己的错误 待人友善 使对方一开始就说“是” 让对方多表现自己 把你的意见变成对方的 站在对方的立场看问题 真诚的同情他人 激发他人产生高尚的动机 巧妙的表达你的意愿 向对方提出有意义的挑战 学会谦逊。 避免与他人发生争论。 当要纠正某人的错误，不应该直率地告诉他，千万别直接说“你错了”，应该在尊重对方的基础上，用一种非常巧妙的方法，才不会得罪对方。 如果你错了，就要勇敢地承认自己的错误。 富兰克林：“如果你辩论和反驳，或许你可以得到胜利，但那胜利是短暂而空虚的，因为你永远得不到对方对你的好感。” 释迦牟尼：“恨永远无法止恨，只有爱才可以止恨。所以误会是不能用争论来解决的，而需要用外交的手腕以及赋予对方同情来解决。 “当我们对的时候，我们要温和而巧妙地去得到人们对我们的赞同；当我们错的时候，如果我们对自己诚实，我们要当即真诚地承认自己的错误。” “如果你想赢得人心，首先就要让他人相信你是最真诚的朋友。这就像用一滴蜂蜜吸引住他的心，于是就有了一条坦然大道，通往他的内心深处。” 法国哲学家罗西法考说：“如果你想要树立敌人，就胜过你的朋友；而如果你要得到朋友，那就要让你的朋友胜过你。”因为当朋友胜过我们的时候，他们获得了一种尊重感；而当我们胜过他们的时候，他们会产生一种自卑感，并引起猜忌和嫉妒。 “要影响别人而使人同意你的意见，你就要使对方觉得这是他的主意。” “对方为什么会有这样的思想和行为，其中一定有他的原因。探寻其中隐藏的原因，你就能得到了解他人行动或人格的钥匙。” “‘我一点都不奇怪你有这种感觉。如果我是你，也会和你有一样的感觉。’你明天要遇到的人，有3/4在渴望同情。你对他们给予同情，他们就会即刻喜爱上你。” “每个人的行事都有两个好理由：一是看起来很好，二是的确很好。” “挑战，是任何成功者都喜爱的一种竞技，一种表现自己的机会；挑战，是证明自身价值以及争强斗胜的机会。你想要使一个富有上进精神和充满血气的人同意你的意见，那么，你就应该记住：给他提出一个挑战。” 5. 如何更好地说服别人 学会赞美和欣赏他人 间接而委婉地提醒对方的错误 首先认识到自己的缺点 不要命令别人 给对方留面子 激励赞赏能创造最伟大的力量 让他人有个好名声 鼓励使他人更容易改正错误 善于向他人授权 在批评他人之前，首先认识到自己的缺点。 为对方留面子。 称赞他人的每个进步，即使这个进步十分渺小。 鼓励他人，使他人对某件事情充满信心。 “批评的人开始时先谦逊地承认，他自己也不是无可指责的，然后再对被批评者说他犯的错误。” “欧文·杨的措辞始终是建议，而不是命令。例如，欧文·杨从没有说过：‘做这个，做那个。’或者是：‘别做这个，别做那个。’他平时对人的措辞是：‘你不妨可以考虑一下。’或者是：‘你认为那个有效吗？’当他拟完一份信稿后，经常会这样问：‘你以为如何？’当他看过助理写的一封信后，他会这样说：‘或者我们这样措辞会比较好一点。’他总是给人自己去做事的机会；他绝不告诉他的助手应该怎样去做，而让他们从错误中去学习经验。” “告诉一个孩子、一个丈夫或是一个员工，他在某一件事上愚蠢至极，他所做的完全不对，那你就破坏了他想要进取、上进的心情。可是，如果运用一种相反的技巧，多给人们一些鼓励，把事情看得很容易。使对方知道，你对他有信心，他有尚未发挥出的才干，那他就会付出最大的努力，争取胜利。” “这就是人类的天性，如果你想让他人乐意去做你所建议的事，那就给他人一个头衔，使他有一种权威的感觉。” 6. 拥有一个幸福快乐的家庭 不要自掘婚姻的坟墓 不要试图改变你的伴侣 在家庭中杜绝批评 发自内心的欣赏对方 对家人殷勤有礼 掌握基本的婚姻知识 不要忽略家庭中的小事 切勿，喋喋不休。 不要试图改变你的伴侣，学会体恤。 不要对家人要求太多，在你想批评他们的时候，温柔一些，你会得到意想不到的效果。 生活中给予对方真诚的欣赏。 在个人的幸福快乐方面，婚姻要比事业更加重要，更加切身。 快乐的婚姻，很少是机会的产物，它们就像建筑，必须是有理智的，用心设计过的。 婚姻本身就是一系列的琐事，不要忽略他们。 “与人交往，第一件要学的事情就是不要干涉他人快乐的特殊方法，如果这些方法和我们不相冲突的话。” “为什么许多甜蜜的美梦，会在结婚以后全部破碎呢？她知道只有一个原因，那就是令人心碎的批评。” “50%以上的婚姻都归于失败；原因之有一个，那就是无用的、令人心碎的批评。” “你应该让你的妻子（或丈夫）知道，你确实很欣赏她（他）。这是保持家庭生活幸福，增进双方感情的有效办法。” “男性对于女性追求美观及装束得体的努力应该表示欣赏。” “对于很多男人而言，他们也许想不起自己5年前穿过什么样的衣服和衬衫，他们也丝毫没有去记它们的意思，而女人则不同。” “下次在她做的烧鸡很嫩时，你就赞美她，使她知道你很欣赏她的手艺，你不只是在吃草。” “不讲道理是吞噬爱情的癌细胞。虽然我们每个人都知道这一点，但糟糕的是，我们对待自己的家人，却不及对待陌生人那样有礼。” “在个人的幸福快乐方面，婚姻要比事业更加重要，更加切身。一般人如果有快乐的婚姻，那远比独身的天才生活得快乐。俄国伟大的小说家屠格涅夫受到了整个文明世界的赞誉，但他说：‘如果在某个地方有一个女人对我过了吃晚饭的时间还没有回家而十分关心，那我宁愿放弃自己所有的文才和著作。’” “其实，很多婚姻破裂的事件中，并不是所有的家庭都是因为一些重大的事件而过不下去的；相反，大多数往往都是因为一些很小的事情。” “自古以来，鲜花都被认为是爱情的语言，它们不会花费你许多钱，特别是在鲜花盛开的季节。但想想，能带一束水仙花回家的丈夫很少，你也许会认为它们都贵如兰花、稀如鼠菊，盛开于阿尔卑斯山云霄的绝壁之上。那为什么要等到你的夫人进了医院才送她几朵花？为什么不在明天晚上就给她带回几朵玫瑰花？” “女人对生日和纪念日都很重视，究竟为什么？因为这种日子永远是一种女性的神秘。很多男人可以糊涂一生，可以不记得许多日期，但有几个不可以忘记：妻子的生日、结婚的年份及日子。你可以记不起她的生日，但切不可忘掉最后一个！”（我觉得都不能忘） “太多的男人都轻视天天注意小事的价值。正如麦道克斯在一篇文章中说：‘美国的家庭真的需要些新习惯。例如，在床上吃早餐是一种放松，许多女人都想恣意地在床上吃早餐，这就像私人俱乐部对于男人的诱惑一样。’” 7. 使自己变得更成熟 勇于担当责任 困难不等于不幸 摆脱不幸福的5种方法 将坚定的信念付诸行动 做独一无二的自己 学会喜欢自己 坚持自我本色 不要做让人生厌的人 争取并珍爱友谊 承担责任：承担自己行为的后果，为自己的行为负责。 不找借口去逃避困难，而是想办法克服困难，正如“真的勇士，敢于直面惨淡的人生，敢于正视淋漓的鲜血”。 困难不意味着不幸，或许它是一种幸运的开始。 不断学习，提升自我，人的一生不总是一帆风顺的，我们总要学会在逆境中生存。 坚定自己的信念，有自己的梦想并付诸行动。（也许这就是许多人（当然，也包括我自己）喜欢《海贼王》的原因吧，因为这里面的每个人物都有自己的梦想，并为之拼命奋斗着。） 行动永远比理论有效。 尽可能从他人的观点看问题，但不可因此失去自己的观点。 做一个有趣而不让人生厌的人。 珍惜友谊和感情，待人真诚；要让自己得到更多的友谊，就要先专心一意的喜欢别人。 学会谦逊，“谦卑先于伟大”。 摆脱不幸的5个方法： 第一，接受不可避免的事实，让时间去治疗伤痛。 第二，采取行动以抵制困境。 第三，集中精神，帮助他人。 第四，在有生之年，充分利用自己的生命。 第五，计算我们所拥有的幸福。 以成熟的态度认识自己： 每天抽出时间独处，进一步认识自己。 挣脱习惯的枷锁，走向社会。 找出生活中最能让我们感兴趣的东西。 发现自我并使之与众不同的方法： 第一，每天为自己安排独处的时刻。 第二，努力破除束缚自我的种种积习。 第三，用热忱与兴奋去追求自己的目标。 没有谁是完美的，每个人都会犯错，重要的我们怎么面对自己的错误。 学会喜欢、尊重和欣赏我们自己，这不但能培养出健康成熟的个性，也能增进与他人相处的能力。 “在日常生活中，如果你留心一下幼儿的生活，你一定会听到或见到更多类似的故事。在孩子们的眼里，他们的这种行为是极其自然的。他们喜欢责怪那些没有生命的东西，或是毫不相干的人物，似乎这样做就可以减轻自己跌倒的痛苦。他们的这种表现是再正常不过的行为了。” “心理不成熟的人总是把自己与众不同的地方看成是缺陷和障碍，然后期望自己能受到特殊的待遇。心理成熟的人则不然，他们先认清自己的不同之处，然后再决定是要接受它们，还是改进它们。” “人不是因为没有信心而跌倒，而是因为不能把信念化成行动，并且不顾一切地坚持到底。” “每个人的生活经历都是独一无二的。尽管构成人体的基因是相同的，但每个人的生命都很奇妙地自成一体，绝不相同。心灵的成熟过程，是持续不断的自我发现、自我探索的过程，除非我们先了解自己，否则我们很难去了解别人。” 心理学家威廉·詹姆斯在1878年写给妻子的信中对此做了精彩的表达：“……我经常认为，要判定一个人的人格，最好的方法就是找出他自己认为最满意的精神或道德态度，这时自己的内心会有一个声音在说：‘这才是真正的我！’”换句话说就是：兴趣让真正的自己浮现，“对人生的满意”让每个人的精神都很振奋。 “我们内心就像幽静的泉水，只有在独处时才能发现其美。” “生活中对自己表示不喜欢的人，表现的症状之一便是过度自我挑剔。适度的自我批评是健康的、有益的，对自我追求进步极有必要。但如果不把握好这其中的分寸，则会使我们的积极行为受到严重影响。” “像追求安全感一样，人们喜欢顺应环境，最后往往使自己成为环境的奴隶。对我们来说，真正意义上的自由，应该是接受生活的各种挑战，是不断奋斗，并经历各种争议。” “言语乏味可以显示出说话的人缺乏智性、想象力和对人的敏感性，而这些特性都是完成健全人格、能对别人有正常反应所不可或缺的重要因素。一个人如果心理成熟或心智继续成长，就能与人讨论任何事情而不致引人生厌。” “与他人相处时，要想赢得别人的友谊或感情，先不要担心别人是否喜欢我们，而是要用心去改善自己的态度，并增进能让别人喜欢你的品质。” “得到友谊的最佳方法，是必须注重施予，而不是获得——应该是亲自赢取得来，而不是靠一时的吸引或哄骗。得到友谊的最佳方法是必须注重施予，而不是获得——应该是亲自赢取得来，而不是靠一时的吸引或哄骗。所谓赢取友谊的能力，并不是指勾肩搭背、与人攀谈、动作滑稽或讲些逗趣的笑话等。那应该指的是一种心境、一种处世的态度或是一种愿意把自己的爱、兴趣、注意力及服务精神献给他人的愿望。” “外交的秘诀仅在5个字：我要喜欢你。” “荷马·克洛维从不担心要如何结交朋友——因为每个人都是他的朋友。他不在意别人是否喜欢自己，而是专心一意去喜欢别人，结果反而达到了‘无心插柳柳成荫’的境界。” 8. 走出孤独忧虑的人生 摆脱孤独的方法 不要让忧虑扼杀幸福的生活 生活在完全独立的今天 消除烦闷的灵丹妙药 克服忧虑的4个步骤 在繁忙中遗忘忧虑 不为小事烦恼 摒弃愚蠢的担忧 接受并适应不可避免的事实 让忧虑“到此为止” 不做无用功 幸福要自己争取。幸福并不是靠别人的布施，而是自己去赢取别人对你的需要和喜爱。 与别人分享自己的快乐。 如果我们以生活为代价，“付”给忧虑太多的话，我们就是傻子。 对未来充满热情，不看远处模糊的事，尽力做好手边清楚的事。 不畏将来，不念过往。用铁门把过去和未来隔断，生活在完全独立的今天。 追求心灵的平静，不拘泥于小事，不为小事烦恼，摒弃不必要的担忧（不要杞人忧天）。 让自己忙碌起来，工作是精神疾病最好的治疗剂。 我们迟早要学到的东西，就是必须接受和适应那些不可避免的事实。 树立正确的价值观。 事情过去了，就让它过去吧。 消除忧虑的万能公式： 第一步，我们要放弃害怕，问你自己：“可能发生的最坏情况是什么？”。 第二步，预计出最坏的情况，让自己敢于接受它。 第三步，平静下来把时间和精力用于改善所面对的问题和困难。 亚里士多德法则，通常会消除我们90%的忧虑： 第一，清楚地写下我们所担心的是什么。 第二，写下我们可以怎么办以及可能产生的结果。 第三，决定该怎么办。 第四，马上按照决定去做。 “初到一个陌生的城市，其实有很多事情可以去做：你可以去教堂或加入俱乐部，这些地方可以增加认识人的机会；你也可以选修成人教育课程，这样不但可以获得知识和取得进步，更可以得到同伴和友谊。但如果你只是一个人默默地在餐馆里吃饭，或在酒吧喝闷酒，那就可能真的得不到什么友谊了。” “我们若想克服孤寂，就必须远离自怜的阴影，勇敢地走入充满光亮的人群中。我们要勇于去认识他人，结交新的朋友。无论在什么地方，都要将自己的欢乐尽量与别人分享。 “无论我们走到哪里，一定要培养与人们亲密的情谊关系。就好像燃烧的煤油灯一样，即使火焰很小，也能产生出光亮和温暖。” “如果你想要享有快乐、健康的人生，那就从现在开始，消除心中的忧虑，远离忧虑的危害。” “忧虑、烦躁、憎恨、懊悔等情绪能伤害身心健康。” “忧虑就像是在不停地往下滴的水珠，而那不停往下滴的忧虑，通常会使人心神发狂，甚至自杀。” “给忧虑设定一个限度，超过这个限度就不再考虑了，让忧虑到此为止。” “我认为人性之中最可悲的一件事，就是我们所有的人都拖延着不去生活，都梦想着在天边有一座奇妙的玫瑰园，而不能欣赏今天就开放在我们窗口的玫瑰花。” “不必去想是否快乐，让自己忙碌起来，你的血液就会加快循环，你的头脑就会变得敏锐。让自己的意志忙着，这是世界上最便宜的一种药，也是最好的一种。” 9. 不为工作和金钱而烦恼 将工作的忧虑减半的4个步骤 选择自己喜欢做的工作 正确处理金钱的烦恼 解决夫妻间的职业冲突 合理规划收入 不要总是花时间担心、讨论出什么问题，用实际行动来解决问题。 选择自己喜欢做的工作，成功的真正意义就是找到一份你所热爱的工作并努力去做。 豁达。 学会合理支配自己的收入，不要浪费，不要为金钱烦恼。(每到发工资的时候就很高兴。。。，可以给泡面加点葱花了~)。 “只有分析清楚问题，才能有效地解决问题，走上成功之路。为此，我们要问自己以下问题：第一，问题是什么？第二，问题的起因是什么？第三，解决问题的方法有哪些？第四，你建议用哪一种解决方法？” “如果我们得不到自己所希望的东西，那最好不要让忧虑和悔恨来侵扰我们的生活。让我们原谅自己，学得豁达一些。古希腊哲学家艾皮科蒂塔说，哲学的精华就是：‘一个人生活上的快乐，应该来自于尽可能减少对外来事物的依赖。’罗马的政治家及哲学家塞尼加也说：“如果你一直都觉得不满足，那即使是给你整个世界，你也会觉得伤心。” “其实，成功的真正意义就是找到一份你所热爱的工作并努力去做——在奋斗的途中必须不顾自身的安全与幸福，有时候只有这样做，才是获得我们真正想要的东西的唯一方法。” “想让自己的丈夫成功，妻子必须心甘情愿地让自己的丈夫去做他最喜爱的任何事情，即使他的做法是一种冒险。” “大家都认为，只要我们的收入能够增多一些，那么所有的忧虑就都可以解决了，这是普遍存在的一个错误观点。” “浪费的原因就是他们从来没有考虑过去改变自己的性格，克制个人欲望。造成现在社会上事事追求浮华虚荣的最大原因，就是人们习惯于随心所欲，任性而为。” “无论你收入多少，你都要量入为出，能节省的地方就尽量节省。任何人都应该根据自己的收入来决定支出，这是人类生活的一条规律。” 10. 防止疲劳，永葆活力 疲劳之前先休息 青春永驻的秘诀 摆脱失眠的困扰 一小时的休息并不是在浪费生命，它能够让你保持更多清醒的时间，使你能够做更多清醒而有效率的事。 在你感到疲劳之前先休息，休息并不是绝对什么事都不做，休息就是“修补”。 避免不必要的操心。 和信任的人谈心。 对他人保持友善。 下面是五条规则，可以让你不为失眠症而忧虑： 第一，如果睡不着的话，就起来工作或看书，直到打瞌睡为止。 第二，从来没有人会因为缺乏睡眠而死。因担心失眠而忧虑，通常对你的损害比失眠更厉害。 第三，试着祈祷，或者像珍妮·麦克唐纳一样诵读诗篇的第二十三篇。 第四，放松全身，看看《消除神经紧张》这本书。 第五，多运动，或做一些体力活，直至你累得酣然入睡。 “在你感到疲劳之前先休息，这样你每天清醒的时间就可以多增加一小时。” “减轻忧虑的最好办法，就是和你信任的人谈论你的问题，把心底的话说出来，就等于打了一针强心剂。” “我们必须感觉到这个世界上还有人愿意听我们说话，也愿意了解我们。 “要对你的邻居有兴趣，对那些和你共同生活在一条街上的人保持一种友善的态度。” “为失眠症而忧虑，对你的伤害程度远远超过失眠症本身。” “治疗失眠症的最好办法，就是使你自己的身体达到疲劳的程度。” “不论一个人有多强的意志力，大自然都会强迫他入睡。大自然会让我们长久不吃东西、不喝水，却不会让我们长久不睡觉。” “要想安稳地睡一夜的第一个必要条件，就是要有安全感。我们必须感觉到有一种比我们大得多的力量，一直照顾我们到天明。”","link":"/exclude/essay/Reading/r1.html"}],"posts":[{"title":"My New Post","text":"","link":"/2021/03/26/My-New-Post/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start (npx hexo)Create a new post12$ hexo new &quot;My New Post&quot;$ hexo new &lt;模版名&gt; &quot;My New Post&quot; More info: Writing Run server123$ hexo server$ hexo s$ hexo s --silent More info: Server Generate static files12$ hexo generate$ hexo g More info: Generating Deploy to remote sites12$ hexo deploy$ hexo d More info: Deployment","link":"/2021/03/26/hello-world/"},{"title":"基于Kaldi（DNN）的小词汇量汉语语音识别平台搭建","text":"基于Kaldi（DNN）的小词汇量汉语语音识别平台搭建 Kaldi 简介1. Kaldi 平台介绍kaldi是使用C++编写的一个开源的语音识别工具箱，支持GMM、DNN以及SGMM等多种模型的训练，这款工具既可以在Windows下编译也可以在Linux系统下编译，这里对Kaldi的编译是在Linux系统下（ubuntu 16.04）进行的。 2. Kaldi 安装 Kaldi源码地址: https://github.com/kaldi-asr/kaldi。 先将源码下载到本地：git clone https://github.com/kaldi-asr/kaldi.git 到tool目录下，在命令行输入: make。Note that “make” takes a long time; you can speed it up by running make in parallel, for instance “make -j 4” 4是机器的cpu核心数，说明比较好。 make 完后，在src目录下执行: 123./configuremake depend make 3. Kaldi 目录文件安装完成后进入Kaldi文件夹，文件夹的内容见下表。其中比较重要的文件夹是&quot;src&quot;和&quot;tools&quot;文件夹，基于本文的工程目录在&quot;egs&quot;文件夹下的&quot;XiaDan&quot;文件夹中。 文件夹名称 内容 src Kaldi源代码和编译脚本 tools Kaldi所依赖的外部库文件，如openfst、ATLAS等 egs Kaldi工程样例，如timit、thchs30、wsj等 misc 一些文档以及以前版本的文本信息 windows Windows环境下安装需要的文件内容 4. XiaDan 工程目录 文件夹名称 内容 wav 训练和测试音频数据文件目录 data 声学数据和字典存放目录 steps、utils、local 用于数据准备以及训练的可执行脚本文件 conf 配置信息文件夹 cmd.sh 环境变量设置脚本 path.sh 设置调用脚本和外部库路径 run.sh 语音识别脚本文件 DNN-HMM 语音识别系统搭建基于Kaldi平台搭建DNN-HMM语音识别系统，这里针对汉语普通话建立语音识别系统，并在后期对识别率进行了分析。搭建一个完整的DNN-HMM系统首先需要准备训练数据，包括音频数据、声学数据和语言数据，这些数据需要按照一定的格式准备，完成之后使用训练脚本训练出一个基于三音素的GMM-HMM模型，然后进行强制对齐，之后使用DNN训练脚本进行DNN模型的训练。1. 数据准备 音频数据 在搭建识别系统前需要录制音频数据，这里使用了18个说话人，每个说话人共录制音频数据40条，其中用于训练的数据有31条，测试数据9条，文件格式为WAV，采样率为16kHZ。把录制好的数据放在可以识别特定说话人的文件夹（wav文件夹，其中wav文件夹包括train和test文件夹，分别保存训练数据和测试数据）中。音频文件命名格式为zh1101M0001，前两个字母代表汉语，1101为说话人ID，M代表性别为男性，0001为文件编号ID。 （说话人文件目录） （部分语音数据） 声学数据 在进行识别训练之前，需要准备相应的声学数据，创建一些文件使Kaldi与音频文件进行关联，需要准备的声学数据文件如图所示。 （声学数据文件） 以下是对一些主要文件进行的说明：wav.scp记录了语音文件的路径，zh1110M0001是音频数据的名称，后面是路径，中间用空格分开，如图所示。 （wav.scp文件内容） text文件包含每一个句子所对应的文本信息，用空格将句子字词分开，部分内容如图所示。 （text文件内容） utt2spk文件告诉ASR系统哪一个句子属于哪个特定的说话人，如图所示。 （utt2spk文件内容） spk2utt文件告诉ASR系统哪些句子属于哪个说话人，部分内容如图所示。 （spk2utt文件内容） 语言数据 这部分实际是在制作字典，字典使用的是汉语的声韵母发音，使用声韵母作为基本的音素，同时加入了声调的变化。在kaldi/egs/XiaDan/data/local目录下，创建一个新的文件夹 &quot;dict&quot;。 在dict文件夹中创建如下文件： （dict文件夹内容） 各个文件的内容如下： silence_phones.txt文件列出了静音音素，在这里只有一个sil。 optional_silence.txt文件列出了可选择的静音音素，也只有一个sil。 lexicon.txt文件包含你的字典里的每一个单词的音素，如图所示。 （发音字典文件） nonsilence_phones.tx文件列出了你工程中的所有的非静音音素，部分音素如图所示。 （非静音音素） 2. 模型训练准备工作完成后，就可以生成语言模型了，语言模型训练这里使用n-gram算法，可以借助sirlm工具可以实现，生成语言模型。这里创建了shell脚本方便运行，运行脚本文件Create_ngram_LM.sh便可得到语言模型文件。 准备好上面这些文件后就可以进行训练了，在这里训练分为三步，并保存在DNN_train.sh脚本文件中。下表列出了用到的训练脚本及其功能。| 脚本名称 | 脚本功能 || :———: | :—-: || make_mfcc.sh | 特征参数提取脚本 || train_mono.sh | 单音素HMM训练脚本，一共进行40次迭代，每两次迭代进行一次对齐操作 || mkgraph.sh | 建立解码网络 || decode.sh | 用来解码并生成WER词错率结果 || align_si.sh | 对指定的数据进行对齐作为新模型的输入 || train_deltas.sh | 用来训练与上下文相关的三音素模型 || train_tanh.sh | 使用tanh激活函数进行深度神经网络训练 |具体的训练过程分为三步，即单音素训练、三音素训练和DNN训练，以下是详细的步骤。 首先，需要训练单音素的HMM1234567从语音话语中提取特征参数：mfcc steps/make_mfcc.sh -- nj 18 data/train exp/make_mfcc/train mfcc然后进行单音素的训练：steps/train_mono.sh -- nj 18 data/train data/lang_bigram exp/mono接下来进行解码操作：utils/mkgraph.sh -- mono data/lang_bigram exp/mono exp/mono/graphsteps/decode.sh --nj 18 exp/mono/graph data/test exp/mono/decode 训练三音素的HMM 三音素是三个音素的序列，三音素在自然语言处理的模型中比较有用。 12345音素对齐：steps/align_si.sh -- boost-silence 1.25 -- nj 18 data/train data/lang_bigram exp/mono exp/mono_ali接下来我们训练三音素模型：steps/train_deltas.sh 2000 16000 delta/train data/lang_bigram exp/mono_ali exp_tri然后生成解码图：utils/mkgrapgh.sh data/lang_bigram exp/tri exp/tri/graph 训练DNN-HMM这里将隐马尔可夫模型的状态建模为深度神经网络，而不是通过高斯混合模型对其进行建模。因此，状态转移概率与上述三元模型保持一致，只是现在状态观测概率将由深度神经网络建模。1234首先对齐以前的三音素模型：steps/align_si.sh -- nj 18 data/train data/lang_bigram exp/tri exp/tri_ali重新使用状态转换模型并且训练DNN状态模型： steps/nnet2/train_tanh.sh --initial-learning-rate 0.015 --final-learning-rate 0.002 --num-hidden-layers 3 --minibatch-size 128 --hidden-layer-dim 256 --num-jobs-nnet 10 --num-epochs 15 data/train data/lang_bigram exp/tri_ali exp/DNN 在这里使用tanh激活函数，初始学习率0.015，最终学习率0.002，使用3个隐藏层（尽管隐藏层的数量越多，性能越好，但由于数据量少，计算资源少，在这里使用了3个隐藏层），隐藏层的节点数256。3. 结果分析模型训练后的识别结果如表所示，其中GMM-HMM模型的词错率为单音素模型的词错率，DNN-HMM是在GMM-HMM训练的基础上将状态观测概率将由深度神经网络建模。从表中可以看出，DNN较GMM对识别率有所提高，识别率受影响的因素比较多，主要因素有语言环境、训练数据、说话人口音等。 训练模型 词错率 GMM-HMM 13.31% DNN-HMM 12.04% 以下是将数据量加大一倍，对同样的数据进行重复训练后得到的词错率。从表中可以看出，通过加大训练的数据量，对每一条数据进行多次训练，识别率有所提高。 训练模型 词错率 :———: :—-: DNN-HMM 9.26% 4. 在线测试之前已经完成了语音识别系统的搭建，这里增加了在线识别功能方便查看识别结果。工程目录下新建online文件夹，online文件夹里包括服务器应用脚本、语音识别脚本、语音数据以及识别结果等。 其中server.c是服务入口文件，voice_recognized.sh和run.sh是用于语音识别的脚本文件，识别结果保存在result.txt文件中。 online-data文件夹下包括audio和models两个文件夹，其中audio里保存了语音文件；models里保存了语音识别的模型文件。 在models文件夹下，其中final.mdl是比较重要的一个文件，这个文件中保存的是学习出来的模型。另外还有words.txt和HCLG.fst，一个是字典文件，另外一个是有限状态机。通过这3个文件，便可以使用识别功能了。 将待识别的语音文件放到audio文件夹下，运行脚本文件run.sh，系统会自动查找目标文件夹online-data/audio下的语音文件并进行识别。其中online-wav-gmm-decode-faster命令用来对wav文件进行识别的，此外还有online-gmm-decode-faster命令，这是用来从麦克风输入声音来识别的，这里我们没有用到。 至此已经完成了整个语音识别系统的搭建，从识别结果来看，识别率较低，识别系统不够完善，需要进行进一步的优化。 （本文只用作交流学习使用，如有不足，请见谅。最后附上Github地址：基于Kaldi（DNN）的小词汇量汉语语音识别平台搭建）","link":"/2021/03/26/ASR/ASR_Kaldi_DNN_Chinese/"},{"title":"语音识别平台 运行出错","text":"如果运行出错，请检查配置是否准确 保证clone下来的文件目录放在kaldi目录下的egs文件夹内 检查path.sh路径是否配置正确（一般不需要改） 检查录音文件路径是否正确：data/train.wav.scp，以及data/test.wav.scp里的内容，保证跟本地的实际音频路径一致（一定要检查，一般必须要修改的）。（ps: 该工程的kaldi安装路径为桌面） 检查Kaldi安装是否正确，一些必须的外部依赖库是否安装 确保安装了irstlm 如果是自己新建的新的工程，运行DNN_train.sh前先运行Create_ngram_LM.sh，注意配置正确Create_ngram_LM.sh里的kaldi安装路径以及工程路径 文件夹名称 内容 src Kaldi源代码和编译脚本 tools Kaldi所依赖的外部库文件，如openfst、ATLAS、irstlm等 egs Kaldi工程样例，如timit、thchs30、wsj等","link":"/2021/03/26/ASR/ASR_Kaldi_Question/"},{"title":"基于HTK开源框架的汉语语音识别 (GMM-HMM)","text":"基于HTK开源框架的汉语语音识别 (GMM-HMM) 基于HTK开源框架的汉语语音识别 (GMM-HMM)step1 : 定义语法并生成词网 step2 : 生成词典 step3 : 生成例句并录音 step4 : 标注数据 得到真值文件 step5 : 数据的特征提取 step6 : 一致初始法创建单音素模型 step7 : 确定静音模型 step8 : 重校准训练数据 step9 : 得到三音素 HMM github项目地址 HTK下载地址","link":"/2021/03/26/ASR/ASR_HTK_Chinese/"},{"title":"小程序个人主页","text":"首页，简介，作品展示 留言功能（需要获取个人公开信息） 技术：使用云开发功能(数据库，文件管理以及云函数)，所有数据获取来自云开发平台；文档编写使用markdown; 富文本解析使用towxml 小程序码：","link":"/2021/03/26/Web/MiniAppPersonalHomepage/"},{"title":"flutter 学习整理","text":"flutter 推荐使用 vscode 进行开发 ，下载一下插件，很好用 flutter 的状态管理 有很多：开源的代表有：flutter_redux, google的BLoc，scoped_model等，及闲鱼的fish-redux，但是我们现在都没用 暂时只用自带的setState来更新数据 flutter学习资源列表：http://www.devio.org/2018/09/09/awesome-flutter/ https://pub.dev/ 这是插件地址，需要用到哪些功能的插件可以在这上面找， 基本都开源的 可以直接看源码 编译打包： 12编译打包安卓工程：命令行运行 flutter build apk编译打包ios工程：命令行运行 flutter build ios --release，然后进入ios工程进行archive 遇到的一些问题： 1234Container 中color属性不能和 decoration同时存在 会报错padding和margin的值不能为负listview 暂时没找到直接滚动到某个cell的方法有些组件必须要在Material组件中才能使用（如果使用CupertinoPageScaffold要注意，Scaffold不会有问题） 常用的一些Widget : iOS风格 Widget import 'package:flutter/cupertino.dart'; SafeArea 安全区域：比如iphone X 会有一个安全区域，SafeArea，让内容显示在安全的可见区域,可以避免一些屏幕有刘海或者凹槽的问题 Container:相当于一个空白的view,可以设置padding和margin布局，可以设置阴影、圆角、边框、样式（decoration）等等，可以在里面放child Row/Column(Flexible、Expanded),Stack,ListView,GridView,GestureDetector（手势）,Align,Text,Image,TextField（输入框）,FlatButton(还有其他样式的button),Offstage(该Widget可根据条件来控制是否显示),BottomNavigationBar,ClipOval,SizedBox,IgnorePointer,ConstrainedBox等 获取设备屏幕相关的一些信息123456789101112131415161718192021222324252627282930// 设备方向 (portrait, landscape)Orientation getDeviceOrientation(BuildContext context) { MediaQueryData mediaQuery = MediaQuery.of(context); return mediaQuery.orientation;}// 屏幕宽度double screenWidth(BuildContext context) { return MediaQuery.of(context).size.width;}// 屏幕高度double screenHeight(BuildContext context) { return MediaQuery.of(context).size.height;}// 状态栏高度double statusBarHeight(BuildContext context) { return MediaQuery.of(context).padding.top;}// 导航栏高度double navBarHeight() { return 44.0;}// 状态栏+导航栏高度double statusAndNavBarHeight(BuildContext context) { return statusBarHeight(context) + navBarHeight();} 这是我们现在这个工程用到的一些插件：（安卓编译的时候要注意AndroidX的问题 ，如果项目不支持需要做处理：1.android项目升级到AndroidX 2.将用到的插件做降级处理（我们现在是这么处理的），现在我们用到的这些插件版本没注释的，都是可以正常编译的，注释掉的有些不行）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124# iOS 风格的图标cupertino_icons: ^0.1.2# 提示fluttertoast: ^3.0.1# web socketweb_socket_channel: ^1.0.9# 网络相关http: ^0.12.0+1dio: ^2.1.0connectivity: ^0.4.2# 存储相关shared_preferences: ^0.5.1+1sqflite: ^1.1.3# 图片/相册相关image_picker: ^0.4.12+1image_picker_saver: ^0.1.0image_cropper: ^0.0.9photo_manager: ^0.2.0# 图片压缩flutter_image_compress: ^0.3.1# 网络图片缓存cached_network_image: ^0.7.0transparent_image: ^1.0.0# 路径相关path_provider: ^0.5.0+1# 路由导航相关fluro: ^1.4.0# webview插件flutter_webview_plugin: ^0.2.1+2# 轮播图flutter_swiper: ^1.1.6# 选择器flutter_picker: ^1.0.9city_pickers: ^0.1.14# 通知event_bus: ^1.1.0# 二维码生成和扫描barcode_scan: ^0.0.8qr_flutter: ^2.0.0+51# cell侧滑flutter_slidable: ^0.4.9# 汉字转拼音lpinyin: ^1.0.7# 索引列表azlistview: ^0.1.1# 长按菜单menu: ^0.1.3# 请求权限 1.0.1permission_handler: ^1.0.1# 缓存管理flutter_cache_manager: ^0.3.2# 极光推送插件jpush_flutter: ^0.0.11# 双向进度条flutter_range_slider: ^1.1.0# 图表相关circle_wheel_scroll: ^0.0.1+1charts_flutter: ^0.6.0# 录音flutter_sound: ^1.4.0# 其他tuple: ^1.0.1# 未使用# intl: ^0.15.0# flutter_localizations:# sdk: flutter# flutter_i18n: ^0.6.2# flutter_section_table_view: ^1.0.3# url_launcher: ^5.0.2# 获取设备信息# device_info: ^0.4.0+1# 日历相关# flutter_calendar: ^0.0.8# flutter_umeng_analytics_fork: ^0.0.3# flutter_wechat: ^0.1.5# flutter_alipay: ^0.1.0# flutter_cupertino_date_picker: ^0.3.0# flutter_local_notifications: ^0.5.2# qrcode_reader: ^0.4.4# photo: ^0.2.0# photo_view: ^0.2.2# bottom_tab_bar:# git: https://github.com/LiuC520/flutter_bottom_tab_bar.git# firebase_database: ^2.0.2# 相机# camera: ^0.4.3+2# 图片下载# image_downloader 0.14.1# bloc# flutter_bloc: ^0.10.1# waveprogressbar_flutter: &quot;^0.1.1&quot;# flutter_circular_chart: ^0.1.0# 地图# flutter_map: ^0.5.0+1# amap_base: ^0.3.5# amap_base:# git:# url: https://github.com/yohom/amap_base_flutter.git# ref: android-support-library# path: base# amap_base_location:# git:# url: https://github.com/yohom/amap_base_flutter.git# ref: android-support-library# path: location# 定位amap_location: ^0.2.0# location: ^2.0.0# amap_base_search:# git:# url: https://github.com/yohom/amap_base_flutter.git# ref: android-support-library# path: search# wifi 信息获取# wifi: ^0.1.5# get_ip: ^0.3.0# ios_network_info: ^0.1.2# wifi_ip: ^0.0.1# wifi_ip:# git: # url: https://github.com/luanvotrongdev/get_wifi_info.git# flutter_circular_chart: ^0.1.0# 折线图# flutter_sparkline: ^0.1.0","link":"/2021/03/26/Flutter/flutterResources/"},{"title":"Towxml介绍","text":"Towxml 是一个可将HTML、Markdown转为微信小程序WXML(WeiXin Markup Language)的渲染库。 用于解决在微信小程序中Markdown、HTML不能直接渲染的问题。 特色 支持代码语法高亮 支持emoji表情:wink: 支持上标、下标、下划线、删除线、表格、视频、图片（几乎所有html元素）…… 支持typographer字符替换 多主题动态支持 极致的中文排版优化 Markdown TodoList 支持事件绑定（这样允许自行扩展功能哟，例如：点击页面中的某个元素，更新当前页面内容等…） 前后端支持 快速上手1. 克隆TOWXML到小程序根目录 1git clone https://github.com/sbfkcel/towxml.git 2. 在小程序app.js中引入库 1234567//app.jsconst Towxml = require('/towxml/main'); //引入towxml库App({ onLaunch: function () { }, towxml:new Towxml() //创建towxml对象，供小程序页面使用}) 3. 在小程序页面文件中引入模版 1234&lt;!--pages/index.wxml--&gt;&lt;!--引入towxml模版入口文件，并使用模版--&gt;&lt;import src=&quot;/towxml/entry.wxml&quot;/&gt;&lt;template is=&quot;entry&quot; data=&quot;{{...article}}&quot;/&gt; 4. 在小程序对应的js中请求数据 1234567891011121314151617181920212223242526272829303132//pages/index.jsconst app = getApp();Page({ data: { //article将用来存储towxml数据 article:{} }, onLoad: function () { const _ts = this; //请求markdown文件，并转换为内容 wx.request({ url: 'http://xxx/doc.md', header: { 'content-type': 'application/x-www-form-urlencoded' }, success: (res) =&gt; { //将markdown内容转换为towxml数据 let data = app.towxml.toJson(res.data,'markdown'); //设置文档显示主题，默认'light' data.theme = 'dark'; //设置数据 _ts.setData({ article: data }); } }); }}) 5. 引入对应的WXSS 12345678910111213/**pages/index.wxss**//**基础风格样式**/@import '/towxml/style/main.wxss';/**如果页面有动态主题切换，则需要将使用到的样式全部引入**//**主题配色（浅色样式）**/@import '/towxml/style/theme/light.wxss';/**主题配色（深色样式）**/@import '/towxml/style/theme/dark.wxss'; OK，大功告成~~ 事件绑定towxml支持以下事件绑定，可自行根据需要为内容添加绑定事件。（不支持bindtap等事件简写方法） 123456789101112'bind:touchstart','bind:touchmove','bind:touchcancel','bind:touchend','bind:tap','bind:longpress','bind:longtap','bind:transitionend','bind:animationstart','bind:animationiteration','bind:animationend','bind:touchforcechange' 123456789101112131415161718192021222324252627282930Page({ data: { isloading: true, article: {} }, onLoad: function () { const _ts = this; //将markdown内容转换为towxml数据，交将当前页面对象传入以创建默认事件对象 let articleData = app.towxml.toJson('&lt;div name=&quot;button&quot; id=&quot;button1&quot;&gt;测试一个可点击的元素&lt;/div&gt;', 'html', _ts); //自定义事件，格式为`event_`+`绑定类型`+`_`+`事件类型` //例如`bind:touchstart`则为： this['event_bind_touchstart'] = (event)=&gt;{ console.log(event.target.dataset._el); // 打印出元素信息 }; // 给todoList添加监听事件 this['eventRun_todo_checkboxChange'] = (event)=&gt;{ console.log(event.detail); // todoList checkbox发生change事件 }; //设置文章数据，并清除页面loading _ts.setData({ article: articleData, isloading: false }); }}) 在WePY框架中使用towxml此处以wepy 1.7.3为例，其它版本请参考 12345678910111213141516171819202122232425# 初始化一个项目wepy init standard myproject# 切换到项目目录cd myproject# 安装依赖npm install# 安装towxmlnpm install towxml --save# 切换到src目录cd src# 克隆或下载towxml库到src目录中git clone https://github.com/sbfkcel/towxml.git# 将`towxml/demo/pages/wepyDemo.wpy`内容替换到`src/pages/index.wpy`# 删除`src/towxml/`目录中未引入的文件（当然，也可不删除。需要保留的文件见上一步wepyDemo.wpy文件中的文件引入依赖）# 开启实时编译wepy build --watch API如果为了追求极致的体验，建议将markdown、html转换为towxml数据的过程放在服务器上，在小程序中直接请求数据即可。 1. 依赖环境 需要 Node.js 环境。（已经安装请忽略） 2. 安装towxml 1npm install towxml 3. 接口使用 1234567891011121314const Towxml = require('towxml');const towxml = new Towxml();//Markdown转WXMLlet wxml = towxml.md2wxml('# Article title');//html转WXMLlet wxml = towxml.html2wxml('&lt;h1&gt;Article title&lt;/h1&gt;');//Markdown转towxml数据let data = towxml.toJson('# Article title','markdown');//htm转towxml数据let data = towxml.toJson('# Article title'); Demo示例 将towxml/demo添加为小程序工程 再克隆towxml到demo目录 使用小程序开发工具编译即可 更新说明2.0.1 video、audio增加封面支持 2.0.0 重写转换核心方法，更小、更快、更全、容错更高 1.5.12 增加Markdown TodoList 支持 1.5.11 调整事件绑定策略，剔除capture-bind绑定方式 调整自定义事件时获取元素属性的方式 event.target.dataset._el元素的所有属性 剔除data-url、data-src、data-alpha、data-id、data-name的支持（因为元素数据传递方式更全，模版代码更少） 1.5.7 调整代码片段在模拟器上与真机不一至的问题 1.5.6 增加事件绑定方法，允许为元素添加自定义事件 LicenseMIT","link":"/2021/03/26/Web/Towxml/"},{"title":"meat http-equiv 属性详解(转)","text":"meat http-equiv 属性详解(转) meat http-equiv 属性详解(转)http-equiv 属性提供了 content 属性的信息/值的 HTTP 头。 http-equiv 属性可用于模拟一个 HTTP 响应头。 引用 meat标签的http-equiv属性语法格式是：＜meta http-equiv=&quot;参数&quot; content=&quot;参数变量值&quot;＞；其中http-equiv属性主要有以下几种参数： 1、Expires(期限)说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。用法： 1&lt;meta http-equiv=&quot;expires&quot; content=&quot;Wed, 20 Jun 2007 22:33:00 GMT&quot;&gt; 注意：必须使用GMT的时间格式。 2、Pragma(cache模式)说明：是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出用法： 1&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; 注意：这样设定，访问者将无法脱机浏览。 3、Refresh(刷新)说明：自动刷新并指向新页面。用法： 1&lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2；URL=http://www.net.cn/&quot;&gt; 注意：其中的2是指停留2秒钟后自动刷新到URL网址。 4、Set-Cookie(cookie设定)说明：如果网页过期，那么存盘的cookie将被删除。用法： 1&lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx;expires=Wednesday, 20-Jun-2007 22:33:00 GMT； path=/&quot;&gt; 注意：必须使用GMT的时间格式。 5、Window-target(显示窗口的设定)说明：强制页面在当前窗口以独立页面显示。用法： 1&lt;meta http-equiv=&quot;Window-target&quot; content=&quot;_top&quot;&gt; 注意：用来防止别人在框架里调用自己的页面。 6、content-Type(显示字符集的设定)说明：设定页面使用的字符集。用法： 12&lt;meta http-equiv=&quot;content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt;&lt;meta http-equiv=&quot;Content-Language&quot; Content=&quot;zh-CN&quot; /&gt; 使用 http-equiv 已经不是规定 HTML 文档的字符集的唯一方式： 12HTML 4.01： &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;HTML5： &lt;meta charset=&quot;UTF-8&quot;&gt; 7、Pics-label(网页等级评定)用法： 1&lt;meta http-equiv=&quot;Pics-label&quot; content=&quot;&quot;&gt; 说明：在IE的internet选项中有一项内容设置，可以防止浏览一些受限制的网站，而网站的限制级别就是通过meta属性来设置的。 8、Page_Enter、Page_Exit 设定进入页面时的特殊效果 1&lt;meta http-equiv=&quot;Page-Enter&quot; content=&quot;revealTrans(duration=1.0,transtion=12)&quot;&gt; 设定离开页面时的特殊效果 12341. &lt;meta http-equiv=&quot;Page-Exit&quot; content=&quot;revealTrans(duration=1.0,transtion=12)&quot;&gt; 注意：离开该页面的渐变跳转 2. &lt;meta http-equiv=&quot;Page-Enter&quot; Content=&quot;blendTrans(Duration=0.5)&quot;&gt;注意：blendTrans是动态滤镜的一种，产生渐隐效果。 Duration的值为网页动态过渡的时间，单位为秒。Transition是过渡方式，它的值为0到23，分别对应24种过渡方式。如下表：| 值 | 过渡方式 | 值 | 过渡方式 || :–: | :—-: | :–: | :—-: || 0 | 盒状收缩 | 12 | 随意溶解 || 1 | 盒状放射 | 13 | 从左右两端向中间展开 || 2 | 圆形收缩 | 14 | 从中间向左右两端展开 || 3 | 圆形放射 | 15 | 从上下两端向中间展开 || 4 | 由下往上 | 16 | 从中间向上下两端展开 || 5 | 由上往下 | 17 | 从右上角向左下角展开 || 6 | 从左至右 | 18 | 从右下角向左上角展开 || 7 | 从右至左 | 19 | 由下往上 || 8 | 垂直百叶窗 | 20 | 从左下角向右上角展开 || 9 | 水平百叶窗 | 21 | 从左上角向右下角展开 || 10 | 水平格状百叶窗 | 22 | 垂直线状展开 || 11 | 垂直格状百叶窗 | 23 | 随机产生一种过渡方式 | 9、清除缓存（再访问这个网站要重新下载！） 1&lt;meta http-equiv=&quot;cache-control&quot; content=&quot;no-cache&quot;&gt; 10、设定网页的到期时间 1&lt;meta http-equiv=&quot;expires&quot; content=&quot;0&quot;&gt; 11、关键字,给搜索引擎用的 1&lt;meta http-equiv=&quot;keywords&quot; content=&quot;keyword1,keyword2,keyword3&quot;&gt; 12.页面描述 1&lt;meta http-equiv=&quot;description&quot; content=&quot;This is my page&quot;&gt;","link":"/2021/03/26/Web/http_equiv/"},{"title":"GitHub Pages + VuePress 构建静态网站","text":"GitHubPages 搭建GitHub Pages，由 GitHub 网站服务，为众多 GitHub 用户提供了良好的服务器部署环境以及域名的工具。使用用户名创建一个名为 username.github.io 的仓库即可，如 veenveenveen.github.io，然后通过VuePress搭建静态网站后进行部署。 VuePress 搭建1. VuePress简介VuePress 是以 Vue驱动的简约静态网站生成工具，通过编写markdown文档并将文件编译为html文件来构建静态网站。 2. 环境搭建新建文件夹(以Desktop/Web/VeenWeb为例)，在该文件夹下创建package.json文件，内容如下 123456789{ &quot;scripts&quot;: { &quot;dev&quot;: &quot;vuepress dev docs&quot;, &quot;build&quot;: &quot;vuepress build docs&quot; }, &quot;devDependencies&quot;: { &quot;vuepress&quot;: &quot;^0.14.8&quot; }} 然后安装vuepress,执行下面的命令会生成node_modules依赖包 1npm install -D vuepress 创建docs目录并在该目录下创建一个markdown文件 1234# 创建一个 docs 目录mkdir docs# 切换到docs目录创建一个 markdown 文件echo '# Hello VuePress' &gt; README.md 此时可以运行下面命令查看效果 ( localhost:8080 ) 1npm run dev 此时只显示了”Hello VuePress”的一个带搜索框的页面，此时说明环境已经搭建完成。 3. 目录结构笔者的目录结构如下 1234567891011121314151617181920VeenWeb - 主工程目录└─ docs - 主要的开发目录 └─ .vuepress - vuepress配置目录 └─ dist - 静态资源默认生成目录 └─ public - 公共资源目录 └─ imgs ├─icon.png ├─ config.js - js配置文件 ├─ override.styl - css覆盖，配置显示颜色等样式 ├─ style.styl - 同上 └─ about - 导航栏（关于） └─ article - 导航栏（文章） └─ essay └─ other └─ technology └─ home - 导航栏（首页） ├─ README.md - 网站默认首页├─ node_mudules - node依赖包├─ deploy.sh - 自动部署脚本├─ package.json - webpack 配置文件 4. 简单配置运行下面的命令生成静态资源，会在docs目录下生成.vuepress目录，该目录默认是隐藏的，可以使用ls -al查看 1npm run build .vuepress目录下创建配置文件config.js，该文件是配置 VuePress 站点的基本文件。文件的一些内容如下，更加详细的配置可以参考VuePress官网。 1234567891011module.exports = { // 左上角标题 title: 'veen', // 描述 description: ' ', // 头部部署，网页小图标 head: [ // ico 配置 ['link', { rel: 'icon', href: '/icon.png' }] ]} 5. 主题配置 主页 要配置主页，需要修改根目录的 README.md 文件，如 123456789101112131415161718192021--- home: true&lt;!-- heroImage: --&gt;actionText: Get Started →actionLink: /home/features:- title: Simplicity First details: Minimal setup with markdown-centered project structure helps you focus on writing.- title: Vue-Powered details: Enjoy the dev experience of Vue + webpack, use Vue components in markdown, and develop custom themes with Vue.- title: Performant details: VuePress generates pre-rendered static HTML for each page, and runs as an SPA once a page is loaded.footer: 文档库 | Copyright © 2018 veenveenveen---int main() { while(alive) { study(); } return 0;} 此时看到的内容如下 导航栏配置 可以通过 themeConfig.nav 配置导航栏12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152module.exports = { // 主题部署 title: 'veen' description: ' ', head: [...], themeConfig: { /** * 右侧导航条 * text - 显示字段 * link - 链接：注意前后带 / 符号 */ nav: [ { text: '主页', link: '/home/' }, /** * 多级菜单 * 开头 text 为一级标题 * 数组内 text 为二级标题 * link 为链接，注意带 / */ { text: '文章', items: [ { text: '技术', link: '/article/technology/' }, { text: '随笔', link: '/article/essay/' }, { text: '其他', link: '/article/other/' } ] }, { text: '关于', link: '/about/' // link: '/about/' }, // 链接到网站 { text: 'Github', link: 'https://www.github.com/veenveenveen' }, ] }} 效果图如下 侧边栏配置 可以通过 themeConfig.sidebar 配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576module.exports = { // 主题部署 title: 'veen' description: ' ', head: [...], themeConfig: { nav: [...], /** * 侧边栏配置：侧边栏组 */ sidebar: { // ------- 文章 ------- // 侧边栏在 /article/technology/ 目录上 '/article/technology/': [ { title: '技术', collapsable: true, children: [ ['', 'README'] ] }, { title: '开发', collapsable: true, children: [ ['one', 'one'], ['two', 'two'] ] }, { title: '前端', collapsable: true, children: [ ['three', 'three'], ] } ], // 侧边栏在 /article/essay/ 目录上 '/article/essay/': [ { title: '随笔', collapsable: false, children: [] }, ['', 'README'] ], // 侧边栏在 /article/other/ 目录上 '/article/other/': [ { title: '其他', collapsable: false, children: [] }, ['', 'README'] ], // ------- 关于 ------- // 侧边栏在 /about/ 目录上 '/about/': [ { title: '关于', collapsable: false, children: [] }, ['', '技术文档'], ['WebSetup', '搭建步骤'], ['MarkDown', 'Markdown介绍'], ['Question', '问题解决'] ] }, // 侧边栏自动显示的深度 默认深度是 1，它提取 h2 标题。将其设置为 0 将禁用标题链接，最大值为2，同时提取 h2 和 h3 标题。 sidebarDepth: 1 }} 侧边栏效果图 6. 部署上面介绍了环境搭建，配置导航栏，侧边栏，具体markdown的编写就要自己来写了。部署脚本deploy.sh如下: 12345678910111213# 自动部署脚本 # 构建npm run build# 导航到构建输出目录cd docs/.vuepress/distgit initgit add -Agit commit -m 'deploy'# 推到你仓库的 master 分支git push -f git@github.com:veenveenveen/veenveenveen.github.io.git master 每次编写完后直接在主工程目录下执行./deploy.sh即可。（先检查一下deploy.sh是否可执行，如果无法执行，可以使用命令chmod 777 deploy.sh修改。） 参考文档 https://pages.github.com/ http://caibaojian.com/vuepress/ https://github.com/LiangJunrong/document-library/blob/master/other-library/Website/GithubPages/DocumentLibrary.md#chapter-one","link":"/2021/03/26/about/GitHub%20Pages%20+%20VuePress%20%E6%9E%84%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/"}],"tags":[{"name":"ASR","slug":"ASR","link":"/tags/ASR/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"}],"categories":[{"name":"创建 &amp; 部署","slug":"创建-部署","link":"/categories/%E5%88%9B%E5%BB%BA-%E9%83%A8%E7%BD%B2/"}]}